[
  {
    "category": "infrastructure",
    "description": "Monorepo initialized with npm workspaces",
    "steps": [
      "Root package.json has workspaces configuration",
      "packages/shared, packages/server, packages/client directories exist",
      "npm install from root installs all package dependencies"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "TypeScript configured for all packages",
    "steps": [
      "Root tsconfig.base.json with shared compiler options",
      "Each package has tsconfig.json extending base",
      "TypeScript project references configured between packages",
      "Strict mode enabled in all packages"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Shared types importable from @jarls/shared",
    "steps": [
      "Server can import types: import { GameState } from '@jarls/shared'",
      "Client can import types: import { GameState } from '@jarls/shared'",
      "TypeScript compiles without errors"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "ESLint configured with TypeScript rules",
    "steps": [
      "eslint.config.js at root with TypeScript plugin (ESLint 9 flat config)",
      "pnpm run lint runs ESLint on all packages",
      "Lint errors fail CI pipeline"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Prettier configured for code formatting",
    "steps": [
      ".prettierrc at root with formatting rules",
      "npm run format runs Prettier on all packages",
      "Consistent code style across codebase"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Git hooks configured with Husky and lint-staged",
    "steps": [
      "Husky installed and configured",
      "Pre-commit hook runs lint-staged",
      "Staged files are linted and formatted before commit"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Jest configured for testing",
    "steps": [
      "jest.config.js at root with project references",
      "ts-jest configured for TypeScript tests",
      "npm test runs all tests",
      "Test files use *.test.ts naming convention"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Server hot-reload configured with nodemon",
    "steps": [
      "nodemon installed in server package",
      "npm run dev starts server with hot-reload",
      "Code changes trigger automatic restart"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Client hot-reload configured with Vite",
    "steps": [
      "Vite configured in client package",
      "npm run dev:client starts Vite dev server",
      "HMR works for instant updates"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Split shared/src/index.ts - extract types.ts",
    "steps": [
      "Create packages/shared/src/types.ts",
      "Move all type/interface definitions (CubeCoord, AxialCoord, Piece, GameState, etc.)",
      "Export all types from types.ts",
      "Update index.ts to import and re-export from types.ts"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Split shared/src/index.ts - extract hex.ts",
    "steps": [
      "Create packages/shared/src/hex.ts",
      "Move hex coordinate functions (axialToCube, cubeToAxial, hexDistance, getNeighbor, etc.)",
      "Import types from types.ts",
      "Update index.ts to re-export from hex.ts"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Split shared/src/index.ts - extract board.ts",
    "steps": [
      "Create packages/shared/src/board.ts",
      "Move board generation functions (generateAllBoardHexes, calculateStartingPositions, etc.)",
      "Import types and hex functions as needed",
      "Update index.ts to re-export from board.ts"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Split shared/src/index.ts - extract combat.ts",
    "steps": [
      "Create packages/shared/src/combat.ts",
      "Move combat functions (calculateAttack, calculateDefense, calculateCombat, detectChain, resolvePush)",
      "Import types and helpers as needed",
      "Update index.ts to re-export from combat.ts"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Split shared/src/index.ts - extract move.ts",
    "steps": [
      "Create packages/shared/src/move.ts",
      "Move move functions (validateMove, applyMove, getReachableHexes, getValidMoves)",
      "Import types, hex, and combat functions as needed",
      "Update index.ts to re-export from move.ts"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Split shared/src/index.ts - finalize and verify",
    "steps": [
      "Update index.ts to only contain re-exports",
      "Run pnpm typecheck to verify all exports work",
      "Verify server and client can still import from @jarls/shared"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Split combat.ts - extract combat-core.ts",
    "steps": [
      "Create combat-core.ts with calculateAttack, calculateDefense, calculateCombat",
      "Update combat.ts to import from combat-core.ts",
      "Update index.ts re-exports if needed",
      "Verify tests pass"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Split move.ts - extract move-validation.ts",
    "steps": [
      "Create move-validation.ts with isPathClear, hasDraftFormation, pathCrossesThrone, validateMove",
      "Update move.ts to import from move-validation.ts",
      "Update index.ts re-exports if needed",
      "Verify tests pass"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Split shared/src/index.test.ts - create test directory",
    "steps": [
      "Create packages/shared/src/__tests__/ directory",
      "Move types-related tests to __tests__/types.test.ts",
      "Verify tests pass with pnpm test"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Re-split hex.test.ts (1274 lines) into hex-coordinates.test.ts and hex-directions.test.ts (max 800 lines each)",
    "steps": [
      "Create __tests__/hex-coordinates.test.ts (~600 lines: coordinate conversions, distance, neighbors)",
      "Create __tests__/hex-directions.test.ts (~600 lines: directions, rings, lines)",
      "Delete original hex.test.ts after extraction",
      "Verify tests pass and each file is under 800 lines"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Re-split board.test.ts (1683 lines) into board-generation.test.ts and board-validation.test.ts (max 800 lines each)",
    "steps": [
      "Create __tests__/board-generation.test.ts (~800 lines: generateAllBoardHexes, hexToPixel, calculateStartingPositions, rotateHex)",
      "Create __tests__/board-validation.test.ts (~800 lines: hasPathToThrone, validateShieldPlacement, placeWarriors, createInitialState, generateId)",
      "Delete original board.test.ts after extraction",
      "Verify tests pass and each file is under 800 lines"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Extract combat-strength.test.ts from index.test.ts (max 800 lines)",
    "steps": [
      "Create __tests__/combat-strength.test.ts",
      "Move getPieceStrength, findInlineSupport, findBracing tests",
      "Import from ../combat.ts and ../combat-core.ts",
      "Verify tests pass and file is under 800 lines"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Extract combat-calculation.test.ts from index.test.ts (max 800 lines)",
    "steps": [
      "Create __tests__/combat-calculation.test.ts",
      "Move calculateAttack, calculateDefense, calculateCombat tests",
      "Import from ../combat.ts",
      "Verify tests pass and file is under 800 lines"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Re-split combat-calculation.test.ts (1347 lines) into combat-attack.test.ts and combat-defense.test.ts (max 800 lines each)",
    "steps": [
      "Create __tests__/combat-attack.test.ts (~650 lines: calculateAttack tests)",
      "Create __tests__/combat-defense.test.ts (~650 lines: calculateDefense, calculateCombat tests)",
      "Delete original combat-calculation.test.ts after extraction",
      "Verify tests pass and each file is under 800 lines"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Extract push-simple.test.ts from index.test.ts (max 800 lines)",
    "steps": [
      "Create __tests__/push-simple.test.ts",
      "Move resolveSimplePush tests",
      "Import from ../combat.ts",
      "Verify tests pass and file is under 800 lines"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Extract push-complex.test.ts from index.test.ts (max 800 lines)",
    "steps": [
      "Create __tests__/push-complex.test.ts",
      "Move resolveEdgePush, resolveCompression, resolvePush, detectChain tests",
      "Import from ../combat.ts",
      "Verify tests pass and file is under 800 lines"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Extract move-validation.test.ts from index.test.ts (max 800 lines)",
    "steps": [
      "Create __tests__/move-validation.test.ts",
      "Move validateMove, pathCrossesThrone, Jarl throne crossing tests",
      "Import from ../move.ts and ../move-validation.ts",
      "Verify tests pass and file is under 800 lines"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Extract move-execution.test.ts from index.test.ts (max 800 lines)",
    "steps": [
      "Create __tests__/move-execution.test.ts",
      "Move getReachableHexes, getValidMoves, applyMove tests",
      "Import from ../move.ts",
      "Verify tests pass and file is under 800 lines"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Extract victory.test.ts from index.test.ts (max 800 lines)",
    "steps": [
      "Create __tests__/victory.test.ts",
      "Move checkThroneVictory, eliminatePlayer, checkLastStanding, checkWinConditions tests",
      "Import from ../move.ts or relevant module",
      "Verify tests pass and file is under 800 lines"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Extract utils.test.ts from index.test.ts (max 800 lines)",
    "steps": [
      "Create __tests__/utils.test.ts",
      "Move getPieceAt, getPieceById, isPathClear, hasDraftFormation, getDirectionBetweenAdjacent, getLineDirection tests",
      "Import from relevant modules",
      "Verify tests pass and file is under 800 lines"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Finalize index.test.ts - should be empty or minimal (max ~800 lines)",
    "steps": [
      "Review remaining tests in index.test.ts",
      "Move any remaining tests to appropriate files",
      "Delete index.test.ts if empty, or keep only integration tests (max ~800 lines)",
      "Run full test suite: pnpm test",
      "Verify all tests pass",
      "Verify all code files are under 800 lines where applicable (documentation allowed)"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Verify no files exceed 800 lines (apart from documentation)",
    "steps": [
      "Review remaining files to check if anyone if way bigger than 800 lines",
      "Think very hard if any of them can be split further",
      "If they can be split, do so, without breaking logical cohesion",
      "Run full test suite: pnpm test",
      "Verify all tests pass",
      "Verify all code files are under 800 lines where applicable (documentation allowed)"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Docker Compose file with PostgreSQL 16 service",
    "steps": [
      "Create docker-compose.yml at project root",
      "Add PostgreSQL 16 service with volume persistence",
      "Configure network for inter-container communication",
      "Add healthcheck for PostgreSQL"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Docker Compose Redis 7 service and npm scripts",
    "steps": [
      "Add Redis 7 service with volume persistence",
      "Add healthcheck for Redis",
      "Add docker:up and docker:down npm scripts",
      "Verify both services start and are accessible"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Database migrations setup with node-pg-migrate",
    "steps": [
      "Install node-pg-migrate in server package",
      "Configure migrations directory and connection",
      "Add db:migrate and db:rollback npm scripts"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Database migration for game tables",
    "steps": [
      "Create migration: game_snapshots table (game_id PK, state_snapshot JSONB, version INT, status VARCHAR, created_at, updated_at)",
      "Create migration: game_events table (event_id PK, game_id FK, event_type VARCHAR, event_data JSONB, created_at)",
      "Add indexes for foreign keys and common queries",
      "Run migrations and verify tables exist"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Database migration for player sessions table",
    "steps": [
      "Create migration: player_sessions table (token PK, game_id, player_id, player_name, expires_at)",
      "Add index on game_id for session lookups",
      "Run migration and verify table exists"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "PostgreSQL connection pool setup",
    "steps": [
      "Install pg and @types/pg in server package",
      "Create packages/server/src/db/pool.ts",
      "Configure pool settings (max 10 connections, 30s idle timeout)",
      "Create query() helper function with error handling"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "PostgreSQL connection pool transactions and export",
    "steps": [
      "Create getClient() for transactions",
      "Add graceful shutdown handling",
      "Export pool and helpers from db/index.ts"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "PostgreSQL connection pool unit test",
    "steps": [
      "Write unit test verifying connection works",
      "Test query helper returns results",
      "Test error handling on bad query"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Redis client setup with ioredis",
    "steps": [
      "Install ioredis in server package",
      "Create packages/server/src/redis/client.ts",
      "Configure connection with REDIS_URL from env",
      "Add auto-reconnection handling"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Redis client error handling and export",
    "steps": [
      "Add error event listeners with logging",
      "Add graceful disconnect on shutdown",
      "Export client from redis/index.ts"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Redis client unit test",
    "steps": [
      "Write unit test verifying connection works",
      "Test set/get operations",
      "Test TTL expiration"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Environment variable management with Zod",
    "steps": [
      "Install dotenv in server package (zod already installed)",
      "Create packages/server/src/config/env.ts",
      "Define Zod schema: DATABASE_URL (string), REDIS_URL (string), PORT (number, default 3000), NODE_ENV (enum)",
      "Parse and validate env vars on import"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Environment config export and documentation",
    "steps": [
      "Throw clear error if validation fails",
      "Export typed config object",
      "Update .env.example with all variables documented"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Vite dev server proxy for API and WebSocket",
    "steps": [
      "Open packages/client/vite.config.ts",
      "Add proxy for /api to http://localhost:3000",
      "Add proxy for /socket.io with WebSocket upgrade support",
      "Configure changeOrigin: true",
      "Test proxy works with mock endpoint"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "CubeCoord and AxialCoord interfaces defined",
    "steps": [
      "CubeCoord interface with q, r, s properties",
      "AxialCoord interface with q, r properties",
      "Exported from @jarls/shared"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "HexDirection type and DIRECTIONS constant defined",
    "steps": [
      "HexDirection type is 0-5 for 6 directions",
      "DIRECTIONS array has all 6 direction vectors",
      "Directions follow consistent hexagonal ordering"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "axialToCube and cubeToAxial conversion functions work",
    "steps": [
      "axialToCube converts (q,r) to (q,r,s)",
      "cubeToAxial converts (q,r,s) to (q,r)",
      "Round-trip conversion preserves values",
      "Unit tests pass for conversion functions"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "hexDistance function calculates correct distance",
    "steps": [
      "hexDistance(a, b) returns shortest path length",
      "Distance from hex to itself is 0",
      "Adjacent hexes have distance 1",
      "Unit tests cover edge cases"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "getNeighbor and getAllNeighbors functions work",
    "steps": [
      "getNeighbor(hex, direction) returns adjacent hex",
      "getAllNeighbors(hex) returns all 6 neighbors",
      "Unit tests verify correct neighbor positions"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "getOppositeDirection function returns correct opposite",
    "steps": [
      "getOppositeDirection(0) returns 3",
      "getOppositeDirection(1) returns 4",
      "All 6 directions map to correct opposites"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "hexLine function draws line between two hexes",
    "steps": [
      "hexLine(a, b) returns array of hexes on line",
      "Line includes start and end hexes",
      "Proper rounding handles edge cases",
      "Unit tests verify line drawing"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "isOnBoard and isOnEdge functions validate positions",
    "steps": [
      "isOnBoard(hex, radius) returns true for valid hexes",
      "isOnBoard returns false for out-of-bounds hexes",
      "isOnEdge(hex, radius) returns true for edge hexes",
      "Unit tests cover boundary cases"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "hexToKey and keyToHex enable Map storage",
    "steps": [
      "hexToKey(hex) returns unique string key",
      "keyToHex(key) reconstructs original hex",
      "Keys work correctly as Map keys"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Game state types fully defined",
    "steps": [
      "PieceType, Piece, Player interfaces defined",
      "GameConfig interface with scaling values",
      "GamePhase, GameState interfaces defined",
      "MoveCommand, MoveResult interfaces defined",
      "GameEvent union type defined"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "getConfigForPlayerCount returns correct scaling",
    "steps": [
      "2 players: radius 3, 5 shields, 5 warriors",
      "Returns correct values from scaling table",
      "Config includes all necessary parameters"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "generateAllBoardHexes creates correct hex count",
    "steps": [
      "Radius 3 generates 37 hexes",
      "Formula 3rÂ² + 3r + 1 verified",
      "All hexes satisfy cube coordinate constraint"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "calculateStartingPositions places Jarls equidistantly",
    "steps": [
      "2-player positions are opposite edges",
      "All Jarls same hex distance from center",
      "Unit tests verify equidistance"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "generateSymmetricalShields places shields fairly",
    "steps": [
      "Shields have rotational symmetry",
      "Shields equidistant from starting positions",
      "No shield on Throne or edge hexes"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "validateShieldPlacement ensures path to Throne",
    "steps": [
      "At least one unobstructed path exists per player",
      "Invalid placements are rejected",
      "Re-generation requested for invalid placements"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "placeWarriors positions Warriors in front of Jarl",
    "steps": [
      "Warriors placed between Jarl and Throne",
      "Warriors form initial formation",
      "Correct number of Warriors placed"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "createInitialState generates complete game state",
    "steps": [
      "Full GameState object created",
      "All pieces positioned correctly",
      "Players initialized with IDs",
      "Game phase set to 'setup'"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "getPieceAt and getPieceById helpers work",
    "steps": [
      "getPieceAt(state, position) returns piece or undefined",
      "getPieceById(state, pieceId) returns piece or undefined",
      "Both handle missing pieces gracefully"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "isPathClear checks for blocking pieces",
    "steps": [
      "Returns true when path has no pieces",
      "Returns false when piece blocks path",
      "Checks all hexes between start and end"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "hasDraftFormation detects 2+ Warriors behind Jarl",
    "steps": [
      "Returns true with 2 consecutive Warriors behind",
      "Returns true with 2 non-consecutive Warriors in line",
      "Returns false with only 1 Warrior behind",
      "Unit tests cover gap scenarios"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "validateMove checks all move rules",
    "steps": [
      "Validates piece exists and belongs to player",
      "Validates it's player's turn",
      "Validates game is in playing phase",
      "Validates destination distance for piece type",
      "Validates path is clear"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Validate Jarl 2-hex moves cannot pass through Throne",
    "steps": [
      "In validateMove, when Jarl moves 2 hexes, call hexLine(from, to)",
      "If any hex in path is Throne (0,0), block at Throne instead",
      "Set destination to Throne hex, trigger immediate victory"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Unit tests for Jarl 2-hex Throne crossing",
    "steps": [
      "Unit tests: Jarl 2-hex move crossing Throne stops there and wins",
      "Unit tests: Jarl 2-hex move not crossing Throne works normally"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Implement hasLegalMoves function",
    "steps": [
      "Add hasLegalMoves(state, playerId) function",
      "Check all player's pieces for reachable hexes",
      "Return true if any piece has valid moves"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Enforce no-pass rule with turn skip",
    "steps": [
      "If hasLegalMoves returns true, player MUST move",
      "If hasLegalMoves returns false (extremely rare), allow turn skip"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Unit tests for no-pass rule",
    "steps": [
      "Unit tests: cannot skip when legal moves exist",
      "Unit tests: can skip when completely boxed in by shields/edges/pieces"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Validate friendly piece blocking in paths",
    "steps": [
      "In validateMove, ensure path is clear of ALL pieces (friend or foe)",
      "Cannot move through friendly pieces",
      "Cannot land on friendly pieces (already covered)"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Unit tests for friendly piece blocking",
    "steps": [
      "Unit tests: cannot move through own Warrior",
      "Unit tests: push chain stops if would push ally"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "findInlineSupport finds pieces behind attacker",
    "steps": [
      "Returns array of pieces directly behind in line",
      "Sums strength of all supporting pieces",
      "Stops at empty hex or enemy piece"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "findBracing finds pieces behind defender",
    "steps": [
      "Returns array of pieces directly behind defender",
      "Opposite direction from push",
      "Sums strength of all bracing pieces"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "calculateAttack computes total attack power",
    "steps": [
      "Adds base strength (1 Warrior, 2 Jarl)",
      "Adds +1 momentum if moved 2 hexes",
      "Adds inline support strength",
      "Returns total attack value"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "calculateDefense computes total defense power",
    "steps": [
      "Adds base strength (1 Warrior, 2 Jarl)",
      "Adds bracing support strength",
      "Returns total defense value"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "calculateCombat returns full CombatResult",
    "steps": [
      "Returns attack and defense values",
      "Returns attack/defense breakdowns",
      "Returns outcome (push or blocked)",
      "Used for combat preview"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "detectChain identifies all pieces in push chain",
    "steps": [
      "Returns array of pieces that will move",
      "Identifies chain terminator (edge, shield, throne, empty)",
      "Handles mixed allegiance chains"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "resolveSimplePush moves piece to empty hex",
    "steps": [
      "Defender moves one hex in push direction",
      "Attacker takes defender's original position",
      "Generates MOVE and PUSH events"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "resolveEdgePush eliminates pieces at edge",
    "steps": [
      "Piece at edge is removed from game",
      "Chain compresses toward edge",
      "Multiple eliminations handled",
      "Generates ELIMINATED events"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "resolveCompression handles shield and throne blocking",
    "steps": [
      "Pieces compress against blocker",
      "No pieces eliminated in compression",
      "Attacker takes first defender's position"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Warriors stop adjacent to Throne in push chains",
    "steps": [
      "In detectChain, check if next hex is Throne",
      "If next piece is Warrior and next hex is Throne, mark as compression terminator",
      "Warriors compress against Throne like they do against Shields"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Unit tests for Warrior Throne compression",
    "steps": [
      "Unit tests: Warrior pushed toward Throne stops adjacent",
      "Unit tests: Chain with multiple Warriors compresses at Throne edge",
      "Unit tests: Jarl CAN enter Throne voluntarily (no compression for Jarl)"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "resolvePush main resolver handles all scenarios",
    "steps": [
      "Detects chain and terminator",
      "Routes to correct resolution function",
      "Generates events with correct depth for animation",
      "Returns all state changes"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "checkThroneVictory detects voluntary throne entry",
    "steps": [
      "Returns true when Jarl voluntarily moves to Throne",
      "Returns false for pushed Jarl (compression blocks)",
      "Only player's own turn counts"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "eliminatePlayer removes all player's pieces",
    "steps": [
      "Marks player as eliminated",
      "Removes all remaining Warriors",
      "Player cannot take further turns"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "checkLastStanding detects sole survivor",
    "steps": [
      "Returns winner ID when only one Jarl remains",
      "Returns null if multiple Jarls exist",
      "Triggers immediately on last elimination"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "checkWinConditions checks both conditions with precedence",
    "steps": [
      "Checks throne victory first",
      "Checks last standing second",
      "Returns correct winner and condition"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "getReachableHexes returns all valid destinations",
    "steps": [
      "Warriors: 1-2 hexes in straight lines",
      "Jarl: 1 hex, or 2 with draft",
      "Excludes blocked paths and friendly pieces"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "getValidMoves returns ValidMove array with previews",
    "steps": [
      "Each ValidMove includes destination",
      "Includes move type (move vs attack)",
      "Includes hasMomentum flag",
      "Includes combat preview for attacks"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Implement checkStarvationTrigger function",
    "steps": [
      "Add checkStarvationTrigger(state: GameState) function in shared/src/index.ts",
      "Return { triggered: false } if roundsSinceElimination < 10",
      "Return { triggered: true, isInitial: true } at exactly 10 rounds",
      "Return { triggered: true, isInitial: false } at 15, 20, 25... rounds",
      "Export function"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Unit tests for checkStarvationTrigger",
    "steps": [
      "Add unit tests: no trigger at 0-9 rounds",
      "Add unit tests: trigger at 10, 15, 20 rounds",
      "Add unit tests: no trigger at 11, 12, 13, 14 rounds"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Define StarvationCandidates type",
    "steps": [
      "Add StarvationCandidates type: { playerId: string, candidates: Piece[], maxDistance: number }[]",
      "Export type from @jarls/shared"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Implement calculateStarvationCandidates function",
    "steps": [
      "Add calculateStarvationCandidates(state: GameState) function",
      "Group Warriors by playerId",
      "For each player, calculate hexDistance from Throne (0,0) for each Warrior",
      "Find max distance for that player",
      "Return all Warriors at max distance (ties possible)"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Unit tests for calculateStarvationCandidates",
    "steps": [
      "Add unit tests: single warrior per player",
      "Add unit tests: multiple warriors, clear furthest",
      "Add unit tests: tie scenario with 2 warriors equidistant",
      "Add unit tests: player with no warriors returns empty candidates"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Define StarvationChoice type and function signature",
    "steps": [
      "Add StarvationChoice type: { playerId: string, pieceId: string }",
      "Add StarvationResult type: { newState, events, gameEnded, winnerId }",
      "Export types from @jarls/shared"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Implement resolveStarvation core logic",
    "steps": [
      "Add resolveStarvation(state: GameState, choices: StarvationChoice[]) function",
      "Validate each choice is a valid candidate",
      "Remove selected Warriors from state.pieces",
      "Generate STARVATION_ELIMINATED event for each removed Warrior"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Implement resolveStarvation game end checks",
    "steps": [
      "Reset roundsSinceElimination to 0",
      "Check for last standing victory after eliminations",
      "Return { newState, events, gameEnded, winnerId }",
      "Export function"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Unit tests for resolveStarvation",
    "steps": [
      "Add unit tests: normal starvation removes warriors",
      "Add unit tests: counter resets to 0",
      "Add unit tests: last standing victory triggered by starvation"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Add Jarl starvation grace period tracking",
    "steps": [
      "Track roundsSinceLastWarrior per player in game state",
      "When player loses last Warrior, start 5-round grace period",
      "Add JARL_STARVED event type to GameEvent union"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Implement Jarl elimination after grace period",
    "steps": [
      "During starvation trigger, if player has no Warriors AND grace period passed (5+ rounds)",
      "Eliminate that player's Jarl immediately",
      "Generate JARL_STARVED event",
      "Check for last standing victory after Jarl elimination"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Unit tests for Jarl starvation grace period",
    "steps": [
      "Unit tests: Jarl survives during 5-round grace period",
      "Unit tests: Jarl eliminated after grace period expires"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "applyMove executes move and returns result",
    "steps": [
      "Review existing applyMove implementation in shared/src/index.ts",
      "Ensure it handles simple move (no combat) correctly",
      "Ensure it handles attack with successful push",
      "Ensure it handles blocked attack (attacker stops adjacent)"
    ],
    "passes": true
  },
  {
    "category": "core-logic",
    "description": "Validate blocked attack positioning",
    "steps": [
      "In applyMove, when attack is BLOCKED (Attack <= Defense)",
      "Move attacker to hex adjacent to defender (last clear hex before target)",
      "Attacker does NOT take defender's position",
      "Generate MOVE event with blocked destination"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Install XState v5 in server package",
    "steps": [
      "Install xstate@5 in server package",
      "Create packages/server/src/game/types.ts",
      "Define GameMachineInput for actor creation"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Define game machine context types",
    "steps": [
      "Define GameMachineContext extending GameState with: turnTimerMs, disconnectedPlayers, starvationChoices",
      "Export GameMachineContext type"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Define game machine event types",
    "steps": [
      "Define GameMachineEvent union: PLAYER_JOINED, PLAYER_LEFT, START_GAME, MAKE_MOVE, STARVATION_CHOICE, TIMEOUT, PLAYER_DISCONNECTED, PLAYER_RECONNECTED",
      "Define each event's payload type",
      "Export all event types"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Create game machine skeleton with lobby state",
    "steps": [
      "Create packages/server/src/game/machine.ts",
      "Import createMachine from xstate",
      "Define gameMachine with initial 'lobby' state",
      "Add guard canStartGame: context.players.length >= 2"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement lobby state event handlers",
    "steps": [
      "On PLAYER_JOINED: add player to context.players array (max 2 for MVP)",
      "On PLAYER_LEFT: remove player from context.players",
      "On START_GAME with guard: transition to 'setup'"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Unit tests for lobby state",
    "steps": [
      "Add unit tests: player joins successfully",
      "Add unit tests: player leaves successfully",
      "Add unit tests: cannot start with < 2 players",
      "Add unit tests: can start with 2 players"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement setup state that initializes board",
    "steps": [
      "Add 'setup' state to machine",
      "In entry action: call createInitialState(context.players) from shared",
      "Merge generated state into context",
      "Set context.phase = 'playing'"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Setup state transition to playing",
    "steps": ["Use 'always' transition to immediately go to 'playing' state"],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Unit tests for setup state",
    "steps": [
      "Add unit tests: board is generated on entering setup",
      "Add unit tests: correct number of pieces placed",
      "Add unit tests: transitions to playing automatically"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Add playing state structure",
    "steps": [
      "Add 'playing' compound state with 'awaitingMove' initial substate",
      "Add 'checkingGameEnd' substate",
      "Add 'ended' state"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement MAKE_MOVE handler",
    "steps": [
      "On MAKE_MOVE: validate move.playerId === currentTurnPlayerId",
      "Call validateMove from shared to check legality",
      "If invalid: return error, stay in awaitingMove",
      "If valid: call applyMove, update context with newState and events"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement checkingGameEnd substate",
    "steps": [
      "Transition to 'checkingGameEnd' after move",
      "In checkingGameEnd: check if gameEnded flag is set",
      "If ended: transition to 'ended' state",
      "If not ended: transition back to 'awaitingMove'"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Unit tests for playing state",
    "steps": [
      "Add unit tests: valid move updates state",
      "Add unit tests: invalid move rejected",
      "Add unit tests: game ends on victory"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement rotating first player each round",
    "steps": [
      "Add roundNumber and firstPlayerIndex to game state",
      "After all players move once, increment firstPlayerIndex = (firstPlayerIndex + 1) % playerCount",
      "Turn sequence each round starts from firstPlayerIndex"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Unit tests for rotating first player",
    "steps": [
      "Unit tests: 2-player rotation P0,P1 -> P1,P0 -> P0,P1",
      "Unit tests: 3-player rotation P0,P1,P2 -> P1,P2,P0 -> P2,P0,P1"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement turn timer delayed transition",
    "steps": [
      "Add turnTimerMs to context (null = disabled, or 30000/60000/120000)",
      "In 'awaitingMove' state: add after() delayed transition",
      "Delay uses context.turnTimerMs if not null",
      "If turnTimerMs is null: no timeout (wait indefinitely)"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement autoSkipTurn action",
    "steps": [
      "On timeout: execute autoSkipTurn action (advance turn without move)",
      "Generate TURN_SKIPPED event",
      "Transition to checkingGameEnd"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Unit tests for turn timer",
    "steps": [
      "Add unit tests with fake timers: turn skipped after timeout",
      "Add unit tests: no skip when timer disabled"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Add starvation state structure",
    "steps": [
      "In 'checkingGameEnd': also check checkStarvationTrigger()",
      "If starvation triggered: transition to 'starvation' state",
      "In 'starvation' entry: call calculateStarvationCandidates(), store in context"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement starvation choice handler",
    "steps": [
      "On STARVATION_CHOICE: record choice in context.starvationChoices",
      "Add guard allChoicesMade: all players with candidates have chosen",
      "When all choices made: call resolveStarvation()"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement starvation auto-timeout",
    "steps": [
      "If auto-timeout needed (use turn timer or 30s default): auto-select random candidate",
      "Update context with result",
      "Transition to 'checkingGameEnd' or 'ended'"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Unit tests for starvation state",
    "steps": [
      "Add unit tests: starvation flow with manual choices",
      "Add unit tests: auto-select on timeout"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Add paused state structure",
    "steps": [
      "Add 'paused' state to machine",
      "On PLAYER_DISCONNECTED: start 2-minute timer, mark player as disconnected",
      "If in 'awaitingMove' and disconnected player's turn: transition to 'paused'"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement reconnection handling",
    "steps": [
      "In 'paused': wait for PLAYER_RECONNECTED or timeout",
      "On PLAYER_RECONNECTED: mark player connected, return to previous state",
      "On 2-minute timeout: stay paused (game waits - future: configurable)"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Unit tests for disconnection",
    "steps": [
      "Add unit tests: game pauses on disconnect",
      "Add unit tests: game resumes on reconnect"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement saveSnapshot and loadSnapshot",
    "steps": [
      "Create packages/server/src/game/persistence.ts",
      "Implement saveSnapshot(gameId, state, version): INSERT or UPDATE game_snapshots with optimistic locking",
      "Implement loadSnapshot(gameId): SELECT from game_snapshots, return null if not found",
      "Add version check in saveSnapshot to prevent concurrent conflicts"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement saveEvent and loadEvents",
    "steps": [
      "Implement saveEvent(gameId, event): INSERT into game_events",
      "Implement loadEvents(gameId): SELECT all events ordered by created_at",
      "Export all functions"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Integration tests for persistence",
    "steps": [
      "Add integration tests with test database",
      "Test saveSnapshot creates and updates records",
      "Test loadSnapshot returns correct data"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Integrate persistence with GameManager create",
    "steps": [
      "Update GameManager.create() to save initial snapshot to database",
      "Subscribe to actor state changes: save snapshot on each change",
      "Save events to game_events table for each transition"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement GameManager recover",
    "steps": [
      "Implement recover(): load active games from database on server start",
      "Recreate actors from snapshots",
      "Add games to in-memory Map"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Integration tests for persistence with GameManager",
    "steps": [
      "Add integration tests: create game persists to DB",
      "Add integration tests: recover loads games from DB"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Create GameManager class structure",
    "steps": [
      "Create packages/server/src/game/manager.ts",
      "Create GameManager class with Map<gameId, Actor>",
      "Implement create(config): create actor, generate gameId, return gameId"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement GameManager getState and listGames",
    "steps": [
      "Implement getState(gameId): return current snapshot",
      "Implement listGames(filter?): return array of game summaries"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Unit tests for GameManager CRUD",
    "steps": [
      "Add unit tests for create",
      "Add unit tests for getState",
      "Add unit tests for listGames"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement GameManager player management",
    "steps": [
      "Implement join(gameId, playerName): send PLAYER_JOINED, return playerId",
      "Implement leave(gameId, playerId): send PLAYER_LEFT",
      "Implement start(gameId, playerId): validate is host, send START_GAME"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Unit tests for GameManager player management",
    "steps": ["Add unit tests for join", "Add unit tests for leave", "Add unit tests for start"],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement GameManager move execution",
    "steps": [
      "Implement makeMove(gameId, playerId, command): send MAKE_MOVE, return result",
      "Implement submitStarvationChoice(gameId, playerId, pieceId): send STARVATION_CHOICE",
      "Subscribe to actor state changes for event emission"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Unit tests for GameManager move execution",
    "steps": ["Add unit tests for makeMove", "Add unit tests for submitStarvationChoice"],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Implement GameManager disconnection",
    "steps": [
      "Implement onDisconnect(gameId, playerId): send PLAYER_DISCONNECTED",
      "Implement onReconnect(gameId, playerId): send PLAYER_RECONNECTED"
    ],
    "passes": true
  },
  {
    "category": "state-machine",
    "description": "Integration tests for GameManager disconnection and recovery",
    "steps": [
      "Add integration tests for disconnect",
      "Add integration tests for reconnect",
      "Add integration tests for recovery"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Set up Express app with body parser",
    "steps": [
      "Install express, cors, helmet in server package",
      "Create packages/server/src/server.ts",
      "Create Express app with JSON body parser",
      "Add CORS configuration (allow localhost:5173 for dev)"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Add Express security and health endpoint",
    "steps": [
      "Add helmet for security headers",
      "Add request logging middleware",
      "Create GET /health endpoint returning { status: 'ok', timestamp }",
      "Export app and createServer() function"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Unit test for health endpoint",
    "steps": ["Add basic test: health endpoint returns 200"],
    "passes": true
  },
  {
    "category": "network",
    "description": "Create error classes",
    "steps": [
      "Create packages/server/src/errors/index.ts",
      "Create GameError base class with code, message, statusCode",
      "Create GameNotFoundError (404)",
      "Create InvalidMoveError (400)"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Create additional error classes",
    "steps": [
      "Create NotYourTurnError (400)",
      "Create UnauthorizedError (401)",
      "Create ValidationError (400)"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Create error middleware",
    "steps": [
      "Create packages/server/src/middleware/error.ts",
      "Implement error middleware: catch all errors, return { error, message, details? }",
      "Hide stack traces in production",
      "Log errors with context"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Implement session service",
    "steps": [
      "Create packages/server/src/services/session.ts",
      "Implement createSession(gameId, playerId, playerName): generate 64-char token, store in Redis with 24h TTL",
      "Implement validateSession(token): get from Redis, return { gameId, playerId, playerName } or null"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Implement session service additional methods",
    "steps": [
      "Implement invalidateSession(token): delete from Redis",
      "Implement extendSession(token): refresh TTL to 24h"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Implement auth middleware",
    "steps": [
      "Create packages/server/src/middleware/auth.ts",
      "Implement authenticateSession middleware: extract Bearer token, validate, attach to req"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Unit tests for session service and auth middleware",
    "steps": ["Add unit tests for session service", "Add unit tests for auth middleware"],
    "passes": true
  },
  {
    "category": "network",
    "description": "Implement game creation and listing endpoints",
    "steps": [
      "Create packages/server/src/routes/games.ts",
      "POST /api/games: validate body with Zod, call GameManager.create(), return { gameId }",
      "GET /api/games: call GameManager.listGames(), return array"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Implement game join and state endpoints",
    "steps": [
      "GET /api/games/:id: require auth, call GameManager.getState(), return state",
      "POST /api/games/:id/join: validate body (playerName), call GameManager.join(), create session, return { sessionToken, playerId }"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Implement game start and valid moves endpoints",
    "steps": [
      "POST /api/games/:id/start: require auth, validate is host, call GameManager.start()",
      "GET /api/games/:id/valid-moves/:pieceId: require auth, call getValidMoves from shared, return array",
      "Mount routes in server.ts"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Integration tests for REST API endpoints",
    "steps": ["Add integration tests for each endpoint"],
    "passes": true
  },
  {
    "category": "network",
    "description": "Set up Socket.IO server",
    "steps": [
      "Install socket.io in server package",
      "Create packages/server/src/socket/server.ts",
      "Create and configure Socket.IO server",
      "Attach to HTTP server from Express"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Define Socket.IO event types",
    "steps": [
      "Create packages/server/src/socket/types.ts",
      "Define ClientToServerEvents: joinGame, playTurn, startGame, starvationChoice, disconnect",
      "Define ServerToClientEvents: gameState, turnPlayed, gameEnded, playerJoined, playerLeft, starvationRequired, error"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Configure Socket.IO options",
    "steps": [
      "Configure Connection State Recovery (2-min window)",
      "Configure CORS to match Express"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Implement Socket.IO game lifecycle handlers",
    "steps": [
      "Create packages/server/src/socket/handlers.ts",
      "On 'joinGame': validate session token, join socket to game room, emit current gameState",
      "On 'startGame': validate session is host, call GameManager.start(), broadcast gameState"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Integration tests for Socket.IO lifecycle handlers",
    "steps": [
      "Add integration tests for joinGame handler",
      "Add integration tests for startGame handler"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Implement Socket.IO move execution handler",
    "steps": [
      "On 'playTurn': validate session, call GameManager.makeMove()",
      "Broadcast turnPlayed to room with events and newState",
      "Handle validation errors, emit error to client"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Integration tests for playTurn handler",
    "steps": ["Add integration tests for playTurn handler"],
    "passes": true
  },
  {
    "category": "network",
    "description": "Implement Socket.IO starvation handler",
    "steps": [
      "On 'starvationChoice': call GameManager.submitStarvationChoice()",
      "Subscribe to GameManager events: broadcast starvationRequired when triggered",
      "Broadcast resolution results to room"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Integration tests for starvation handler",
    "steps": ["Add integration tests for starvationChoice handler"],
    "passes": true
  },
  {
    "category": "network",
    "description": "Implement Socket.IO connection management",
    "steps": [
      "On 'disconnect': call GameManager.onDisconnect(), broadcast playerLeft",
      "Handle connection recovery: rejoin room, emit current state",
      "Subscribe to GameManager: broadcast gameEnded when game ends"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Integration tests for connection management",
    "steps": [
      "Add integration tests for disconnect",
      "Add integration tests for reconnect",
      "Add integration tests for recovery"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Create server entry point config loading",
    "steps": [
      "Create packages/server/src/index.ts",
      "Load environment config",
      "Initialize database pool",
      "Initialize Redis client"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Create server entry point app wiring",
    "steps": [
      "Create Express app and HTTP server",
      "Attach Socket.IO",
      "Initialize GameManager",
      "Call GameManager.recover() to load active games"
    ],
    "passes": true
  },
  {
    "category": "network",
    "description": "Create server entry point startup and shutdown",
    "steps": [
      "Start listening on PORT",
      "Add graceful shutdown handling (close connections)",
      "Update package.json start script"
    ],
    "passes": true
  },
  {
    "category": "ai",
    "description": "Define AI types and interface",
    "steps": [
      "Create packages/server/src/ai/types.ts",
      "Define AIPlayer interface: generateMove(state, playerId), makeStarvationChoice(candidates)"
    ],
    "passes": true
  },
  {
    "category": "ai",
    "description": "Implement RandomAI class",
    "steps": [
      "Create packages/server/src/ai/random.ts",
      "Implement RandomAI class implementing AIPlayer",
      "generateMove: get all pieces for playerId, get valid moves for each, pick random move",
      "makeStarvationChoice: pick random candidate"
    ],
    "passes": true
  },
  {
    "category": "ai",
    "description": "Add AI thinking delay and export",
    "steps": ["Add configurable thinking delay (500-1500ms random)", "Export RandomAI"],
    "passes": true
  },
  {
    "category": "ai",
    "description": "Unit tests for RandomAI",
    "steps": ["Add unit tests: returned move is always valid"],
    "passes": true
  },
  {
    "category": "ai",
    "description": "Implement scoreMove function",
    "steps": [
      "Create packages/server/src/ai/heuristic.ts",
      "Implement scoreMove(state, move, playerId) function",
      "Score: +100 throne victory, +50 enemy Jarl elimination, +20 enemy piece elimination",
      "Score: +10 successful push, +5 momentum attack"
    ],
    "passes": true
  },
  {
    "category": "ai",
    "description": "Add negative scoring factors",
    "steps": [
      "Score: -30 own Jarl on edge, -10 own piece on edge after move",
      "Score: +3 per hex closer to throne for Jarl",
      "Add small random factor to avoid predictability"
    ],
    "passes": true
  },
  {
    "category": "ai",
    "description": "Implement HeuristicAI class",
    "steps": [
      "Implement HeuristicAI.generateMove: score all moves, pick from top 3 with weighted random"
    ],
    "passes": true
  },
  {
    "category": "ai",
    "description": "Unit tests for HeuristicAI",
    "steps": [
      "Add unit tests: prefers winning moves",
      "Add unit tests: avoids putting Jarl on edge"
    ],
    "passes": true
  },
  {
    "category": "ai",
    "description": "Create Norse name generator",
    "steps": [
      "Create packages/server/src/ai/names.ts with Norse name arrays",
      "Implement generateNorseName() function"
    ],
    "passes": true
  },
  {
    "category": "ai",
    "description": "Integrate AI with GameManager",
    "steps": [
      "Update GameManager: track AI players per game",
      "Implement addAIPlayer(gameId, difficulty): create AI instance, add to game as player",
      "Subscribe to game state changes"
    ],
    "passes": true
  },
  {
    "category": "ai",
    "description": "Implement AI move execution",
    "steps": [
      "When currentTurn is AI player: wait thinking delay, generate move, execute",
      "Handle AI starvation choices automatically",
      "Add 2-second timeout protection (fallback to random move)"
    ],
    "passes": true
  },
  {
    "category": "ai",
    "description": "Integration tests for AI",
    "steps": ["Add integration tests: AI makes moves on its turn"],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Create client directory structure and configuration",
    "steps": [
      "Create directory structure: src/components, src/hooks, src/store, src/utils, src/socket",
      "Configure path aliases in tsconfig.json (@/ for src/)",
      "Install required packages: socket.io-client, zustand",
      "Verify Vite dev server starts correctly"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Create client routing and page placeholders",
    "steps": [
      "Create src/App.tsx with router setup",
      "Create src/pages/Home.tsx placeholder",
      "Create src/pages/Game.tsx placeholder",
      "Create src/pages/Lobby.tsx placeholder",
      "Test navigation between pages works"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Create client component directory structure",
    "steps": [
      "Create src/components/Board/ directory",
      "Create src/components/Game/ directory",
      "Create src/components/Lobby/ directory",
      "Create src/components/Modals/ directory",
      "Create index.ts barrel exports for each directory"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Set up Zustand store structure",
    "steps": [
      "Create src/store/gameStore.ts",
      "Define state: gameState, playerId, sessionToken, connectionStatus, selectedPieceId, validMoves"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Implement Zustand store actions",
    "steps": [
      "Define actions: setGameState, setPlayer, setSession, clearGame, selectPiece, clearSelection",
      "Add computed selectors: isMyTurn, myPieces, currentPlayer",
      "Export useGameStore hook"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Unit tests for Zustand store",
    "steps": ["Add unit tests for store actions"],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Create Socket.IO client",
    "steps": [
      "Create src/socket/client.ts",
      "Create socket instance with autoConnect: false",
      "Create connect(sessionToken) function: set auth, connect",
      "Create disconnect() function"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Add Socket.IO event listeners",
    "steps": [
      "Add event listeners: gameState -> update store, turnPlayed -> update store, etc.",
      "Create src/hooks/useSocket.ts hook",
      "Handle connection states: update store.connectionStatus",
      "Handle reconnection automatically"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Export Socket.IO client",
    "steps": ["Export socket instance and hook"],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Client-side hex coordinate utilities",
    "steps": [
      "Create src/utils/hexMath.ts",
      "Import hex functions from @jarls/shared",
      "Implement hexToPixel(hex, hexSize, centerX, centerY): convert to canvas coordinates",
      "Implement pixelToHex(x, y, hexSize, centerX, centerY): convert click to hex"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Add hex corner calculation and tests",
    "steps": [
      "Implement getHexCorners(centerX, centerY, size): return 6 corner points for drawing",
      "Add unit tests for conversions"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Create BoardRenderer class",
    "steps": [
      "Create src/components/Board/BoardRenderer.ts",
      "Create BoardRenderer class with canvas context",
      "Implement calculateDimensions(boardRadius, canvasWidth, canvasHeight): compute hexSize and center"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Implement hex grid drawing",
    "steps": [
      "Implement drawHex(hex, fillColor, strokeColor): draw single hex",
      "Implement drawGrid(boardRadius): draw all hexes in board",
      "Highlight throne hex at (0,0) with gold color",
      "Draw hex borders with subtle gray"
    ],
    "passes": true
  },
  {
    "category": "frontend",
    "description": "Add BoardRenderer resize handling",
    "steps": ["Add resize handling to recalculate dimensions"],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Implement piece drawing functions",
    "steps": [
      "Add player colors constant: { p1: '#e63946', p2: '#457b9d' }",
      "Implement drawShield(hex): gray hex with shield icon",
      "Implement drawWarrior(piece): colored circle at piece position",
      "Implement drawJarl(piece): larger circle with crown indicator"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Implement piece rendering",
    "steps": [
      "Implement drawPieces(pieces): iterate and draw all pieces",
      "Implement render(state): clear canvas, draw grid, draw pieces",
      "Add piece shadows for visual depth"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Implement move highlight functions",
    "steps": [
      "Implement drawSelection(hex): draw highlight ring around selected piece",
      "Implement drawValidMoves(moves): draw green overlay on move destinations",
      "Implement drawAttackMoves(moves): draw red overlay on attack destinations"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Implement highlight integration",
    "steps": [
      "Implement drawMomentumIndicator(hex): small icon showing +1 attack",
      "Update render() to include highlights based on store state",
      "Add highlight for current player's pieces (subtle glow)"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Create React Board component",
    "steps": [
      "Create src/components/Board/Board.tsx",
      "Create canvas ref and renderer instance",
      "Connect to gameStore for state",
      "Initialize renderer on mount"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Add Board component effects",
    "steps": [
      "Re-render on state changes (useEffect)",
      "Handle window resize: recalculate dimensions, re-render",
      "Export Board component"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Implement click handler and hex detection",
    "steps": [
      "Add onClick handler to Board canvas",
      "Convert click coordinates to hex using pixelToHex",
      "Check if hex contains a piece owned by current player"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Implement piece selection logic",
    "steps": [
      "If own piece and is player's turn: select piece, fetch valid moves",
      "Fetch valid moves via socket or compute locally",
      "Store validMoves in gameStore",
      "If clicking elsewhere: clear selection",
      "Disable selection when not player's turn"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Implement move execution on click",
    "steps": [
      "In Board onClick: check if clicked hex is a valid move destination",
      "If valid destination: emit playTurn via socket",
      "Clear selection while waiting for response",
      "On turnPlayed event: update state (already handled by socket listener)"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Add move execution error handling and touch",
    "steps": [
      "On error: show error toast, restore selection",
      "Add touch event support (onTouchEnd) for mobile"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Create CombatPreview component",
    "steps": [
      "Create src/components/Board/CombatPreview.tsx",
      "Display attack value with breakdown (base + momentum + support)",
      "Display defense value with breakdown (base + bracing)",
      "Display outcome: 'PUSH' or 'BLOCKED'"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Integrate CombatPreview with hover",
    "steps": [
      "Add onMouseMove handler to Board",
      "On hover over attack destination: show tooltip near cursor",
      "On mouse leave or hover elsewhere: hide tooltip",
      "Position tooltip to stay within viewport"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Create AnimationSystem class",
    "steps": [
      "Create src/components/Board/AnimationSystem.ts",
      "Define Animation type: { pieceId, fromHex, toHex, duration, delay, type }",
      "Implement parseEvents(events): convert GameEvents to Animation array"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Implement animation rendering",
    "steps": [
      "Implement animate(animations): return Promise, use requestAnimationFrame",
      "Animate moves: 200ms ease-out",
      "Stagger push chain: 80ms delay per depth level",
      "Animate eliminations: piece flies off canvas edge (400ms)"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Integrate animations with Board",
    "steps": ["Integrate with Board: wait for animation before updating rendered state"],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Create TurnIndicator component",
    "steps": [
      "Create src/components/Game/TurnIndicator.tsx",
      "Display current player name and color",
      "Show 'Your Turn' badge when applicable"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Create Timer component",
    "steps": [
      "Create src/components/Game/Timer.tsx",
      "Display countdown from turnTimerMs",
      "Style urgently when < 10 seconds"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Create PlayerList component",
    "steps": [
      "Create src/components/Game/PlayerList.tsx",
      "List all players with piece counts (Warriors, Jarl status)",
      "Highlight current player",
      "Mark eliminated players with strikethrough"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Create GameEndModal component",
    "steps": [
      "Create src/components/Modals/GameEndModal.tsx",
      "Show on game.phase === 'ended'",
      "Display 'Victory!' or 'Defeat' based on winner",
      "Show win condition (Throne or Last Standing)",
      "Add 'Play Again' button (returns to lobby)"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Add GameEndModal leave button",
    "steps": ["Add 'Leave' button (returns to home)"],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Create StarvationModal component",
    "steps": [
      "Create src/components/Modals/StarvationModal.tsx",
      "Show when starvation selection required",
      "List candidate warriors with their positions",
      "On select: emit starvationChoice via socket",
      "Show countdown timer for auto-select"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Create CreateGameForm component",
    "steps": [
      "Create src/components/Lobby/CreateGameForm.tsx",
      "Form fields: player name input",
      "Opponent type selector (Human/AI)",
      "AI difficulty dropdown (when AI selected)"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Add CreateGameForm timer and submit",
    "steps": [
      "Turn timer dropdown (None, 30s, 60s, 120s)",
      "Submit: POST /api/games, then POST /join",
      "Navigate to waiting room on success"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Create GameList component",
    "steps": [
      "Create src/components/Lobby/GameList.tsx",
      "Fetch GET /api/games on mount",
      "Display list of joinable games with player counts",
      "Join button for each game"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Add GameList join functionality",
    "steps": ["On join: POST /api/games/:id/join, navigate to waiting room"],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Create WaitingRoom component",
    "steps": [
      "Create src/components/Lobby/WaitingRoom.tsx",
      "Connect to socket, join game room",
      "Display player slots (filled/empty)",
      "Host sees Start Game button (enabled when 2 players)"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Add WaitingRoom non-host behavior",
    "steps": ["Non-host sees waiting message", "On startGame event: navigate to Game page"],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Implement lobby routing",
    "steps": [
      "Update src/App.tsx with lobby routes",
      "Route /: Home with create/join options",
      "Route /lobby/create: CreateGameForm",
      "Route /lobby/games: GameList"
    ],
    "passes": false
  },
  {
    "category": "frontend",
    "description": "Add game routing",
    "steps": ["Route /lobby/:gameId: WaitingRoom", "Route /game/:gameId: Game page"],
    "passes": false
  },
  {
    "category": "testing",
    "description": "Set up integration test infrastructure",
    "steps": [
      "Install supertest as dev dependency",
      "Create packages/server/src/__tests__/api.test.ts",
      "Set up test database and Redis (docker-compose.test.yml or in-memory)"
    ],
    "passes": false
  },
  {
    "category": "testing",
    "description": "Integration tests for game creation endpoints",
    "steps": [
      "Test POST /api/games: creates game, returns gameId",
      "Test GET /api/games: lists games in lobby status"
    ],
    "passes": false
  },
  {
    "category": "testing",
    "description": "Integration tests for game join and state endpoints",
    "steps": [
      "Test POST /api/games/:id/join: returns session token",
      "Test GET /api/games/:id: requires auth, returns state",
      "Test POST /api/games/:id/start: requires host, starts game"
    ],
    "passes": false
  },
  {
    "category": "testing",
    "description": "Integration tests for API error cases",
    "steps": [
      "Test error cases: 404 for missing game, 401 for bad token",
      "Clean up test data after each test"
    ],
    "passes": false
  },
  {
    "category": "testing",
    "description": "Set up Socket.IO test infrastructure",
    "steps": [
      "Create packages/server/src/__tests__/socket.test.ts",
      "Set up socket.io-client for testing"
    ],
    "passes": false
  },
  {
    "category": "testing",
    "description": "Integration tests for Socket.IO game events",
    "steps": [
      "Test joinGame: receives gameState",
      "Test playTurn: move executes, all clients receive turnPlayed",
      "Test startGame: game starts, all clients receive gameState"
    ],
    "passes": false
  },
  {
    "category": "testing",
    "description": "Integration tests for Socket.IO error and disconnect",
    "steps": [
      "Test invalid move: error returned, state unchanged",
      "Test disconnect/reconnect: game pauses, resumes",
      "Clean up socket connections after tests"
    ],
    "passes": false
  },
  {
    "category": "testing",
    "description": "Set up Playwright with project configuration",
    "steps": [
      "Install playwright as dev dependency",
      "Create playwright.config.ts with project settings",
      "Create e2e/setup.ts: start server and client before tests",
      "Create e2e/teardown.ts: cleanup after tests",
      "Verify playwright runs with sample test"
    ],
    "passes": false
  },
  {
    "category": "testing",
    "description": "E2E tests for game creation and joining",
    "steps": [
      "Create e2e/lobby.spec.ts",
      "Test: create game from home page",
      "Test: second player joins game from game list",
      "Test: waiting room shows both players"
    ],
    "passes": false
  },
  {
    "category": "testing",
    "description": "E2E tests for game start",
    "steps": ["Test: host can start game when 2 players present"],
    "passes": false
  },
  {
    "category": "testing",
    "description": "E2E tests for gameplay",
    "steps": [
      "Create e2e/gameplay.spec.ts",
      "Test: board renders correctly after game start",
      "Test: click piece shows valid moves highlighted",
      "Test: make a move, verify board updates"
    ],
    "passes": false
  },
  {
    "category": "testing",
    "description": "E2E tests for turn indicator",
    "steps": ["Test: opponent's turn indicator shown"],
    "passes": false
  },
  {
    "category": "testing",
    "description": "E2E tests for game completion",
    "steps": [
      "Create e2e/endgame.spec.ts",
      "Test: play to victory, verify end modal appears",
      "Test: victory condition displayed correctly"
    ],
    "passes": false
  },
  {
    "category": "testing",
    "description": "E2E tests for mobile",
    "steps": [
      "Create e2e/mobile.spec.ts",
      "Test: mobile viewport touch interactions work",
      "Test: responsive layout adapts correctly"
    ],
    "passes": false
  },
  {
    "category": "non-functional",
    "description": "Performance tests for game logic",
    "steps": [
      "Add performance test for getValidMoves: must complete < 10ms",
      "Verify AI move generation: must complete < 2 seconds"
    ],
    "passes": false
  },
  {
    "category": "non-functional",
    "description": "Performance tests for network",
    "steps": [
      "Add performance test for API endpoints: must respond < 100ms",
      "Measure WebSocket latency: must be < 50ms",
      "Run tests with production build",
      "Document results in test output"
    ],
    "passes": false
  },
  {
    "category": "non-functional",
    "description": "Security verification for sessions",
    "steps": [
      "Verify session tokens are 64 chars (sufficient entropy)",
      "Verify all game mutations require valid session",
      "Verify sessions expire after 24 hours"
    ],
    "passes": false
  },
  {
    "category": "non-functional",
    "description": "Security verification for game logic",
    "steps": [
      "Verify players can only move their own pieces",
      "Verify all API input validated with Zod",
      "Verify error messages don't leak sensitive info"
    ],
    "passes": false
  },
  {
    "category": "non-functional",
    "description": "Verify server reliability requirements",
    "steps": [
      "Verify game state persists to database",
      "Verify server recovers active games on restart",
      "Verify optimistic locking prevents concurrent conflicts",
      "Verify connection pool handles reconnection",
      "Verify no memory leaks (run extended test)"
    ],
    "passes": false
  },
  {
    "category": "non-functional",
    "description": "Browser compatibility desktop",
    "steps": [
      "Test in Chrome (latest 2 versions)",
      "Test in Firefox (latest 2 versions)",
      "Test in Safari (latest 2 versions)",
      "Test in Edge (latest 2 versions)"
    ],
    "passes": false
  },
  {
    "category": "non-functional",
    "description": "Browser compatibility mobile",
    "steps": [
      "Test on iOS Safari mobile",
      "Test on Chrome Android mobile",
      "Verify all features work, no console errors"
    ],
    "passes": false
  },
  {
    "category": "non-functional",
    "description": "Verify client reliability requirements",
    "steps": [
      "Verify client only sends commands (server authoritative)",
      "Verify reconnection works with Connection State Recovery",
      "Verify animations maintain 60fps",
      "Verify responsive design works at all viewports",
      "Verify touch input works on mobile"
    ],
    "passes": false
  },
  {
    "category": "deployment",
    "description": "Create Dockerfile build stage",
    "steps": [
      "Create Dockerfile at project root",
      "Stage 1 (build): use node:20-alpine, install deps, build TypeScript"
    ],
    "passes": false
  },
  {
    "category": "deployment",
    "description": "Create Dockerfile production stage",
    "steps": [
      "Stage 2 (production): use node:20-alpine, copy dist and prod deps only",
      "Set NODE_ENV=production",
      "Add HEALTHCHECK instruction",
      "Expose port 3000",
      "Set CMD to start server"
    ],
    "passes": false
  },
  {
    "category": "deployment",
    "description": "Test Dockerfile locally",
    "steps": ["Build and test locally"],
    "passes": false
  },
  {
    "category": "deployment",
    "description": "Create production docker-compose services",
    "steps": [
      "Create docker-compose.prod.yml",
      "Add app service built from Dockerfile",
      "Add postgres service with volume",
      "Add redis service with volume"
    ],
    "passes": false
  },
  {
    "category": "deployment",
    "description": "Configure production docker-compose",
    "steps": [
      "Configure environment variables via .env",
      "Add restart: unless-stopped policies",
      "Add healthchecks for all services",
      "Test full stack starts correctly"
    ],
    "passes": false
  },
  {
    "category": "deployment",
    "description": "Set up CI pipeline workflow file",
    "steps": [
      "Create .github/workflows/ci.yml",
      "Trigger on push to main and pull requests",
      "Set up Node.js 20 with pnpm",
      "Cache pnpm dependencies"
    ],
    "passes": false
  },
  {
    "category": "deployment",
    "description": "Configure CI pipeline services and commands",
    "steps": [
      "Start postgres and redis services",
      "Run pnpm install",
      "Run pnpm lint",
      "Run pnpm test",
      "Run pnpm build"
    ],
    "passes": false
  },
  {
    "category": "deployment",
    "description": "Add CI failure handling",
    "steps": ["Fail workflow on any error"],
    "passes": false
  },
  {
    "category": "deployment",
    "description": "Create README with project setup",
    "steps": [
      "Update README.md with project overview",
      "Add quick start guide (docker-compose up, npm install, npm run dev)",
      "Document development setup step by step",
      "Document all environment variables in README"
    ],
    "passes": false
  },
  {
    "category": "deployment",
    "description": "Create API documentation",
    "steps": [
      "Create docs/API.md",
      "Document all REST endpoints with request/response examples",
      "Include authentication header requirements",
      "Include error response formats"
    ],
    "passes": false
  },
  {
    "category": "deployment",
    "description": "Create WebSocket documentation",
    "steps": [
      "Create docs/WEBSOCKET.md",
      "Document all client-to-server events with payloads",
      "Document all server-to-client events with payloads",
      "Include connection and authentication flow"
    ],
    "passes": false
  },
  {
    "category": "deployment",
    "description": "Create architecture and help documentation",
    "steps": [
      "Add text-based architecture overview diagram to README",
      "Document monorepo structure and package relationships",
      "Add in-app help content (game rules summary)",
      "Create brief turn/combat quick reference"
    ],
    "passes": false
  }
]
