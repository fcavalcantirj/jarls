## Progress Log

### 2026-01-25: Infrastructure - Monorepo Initialization

**Feature Completed**: "Monorepo initialized with npm workspaces"

**Work Done**:
- Created root package.json with pnpm workspaces configuration
- Created pnpm-workspace.yaml for workspace configuration
- Created packages/shared, packages/server, packages/client directories
- Set up package.json for each package with appropriate dependencies:
  - @jarls/shared: Core shared types package
  - @jarls/server: Node.js game server with tsx for development
  - @jarls/client: React + Vite frontend
- Created tsconfig.base.json with strict TypeScript settings
- Created tsconfig.json for each package with project references
- Added basic source files demonstrating cross-package imports
- Verified pnpm install works correctly from root
- Verified pnpm typecheck passes
- Verified pnpm test passes

**Files Created**:
- package.json (root)
- pnpm-workspace.yaml
- tsconfig.base.json
- packages/shared/package.json
- packages/shared/tsconfig.json
- packages/shared/src/index.ts
- packages/server/package.json
- packages/server/tsconfig.json
- packages/server/src/index.ts
- packages/client/package.json
- packages/client/tsconfig.json
- packages/client/vite.config.ts
- packages/client/index.html
- packages/client/src/main.tsx
- packages/client/src/App.tsx

---

### 2026-01-25: Infrastructure - TypeScript Configuration Verified

**Feature Completed**: "TypeScript configured for all packages"

**Verification**:
- Root tsconfig.base.json exists with shared compiler options (target ES2022, strict mode, etc.)
- Each package (shared, server, client) has tsconfig.json extending ../../tsconfig.base.json
- TypeScript project references configured: server and client reference ../shared
- Strict mode enabled via `"strict": true` in tsconfig.base.json
- `pnpm typecheck` passes for all packages

**Files Verified**:
- tsconfig.base.json
- packages/shared/tsconfig.json
- packages/server/tsconfig.json
- packages/client/tsconfig.json

---

### 2026-01-25: Infrastructure - Shared Types Importable

**Feature Completed**: "Shared types importable from @jarls/shared"

**Work Done**:
- Added core game types to packages/shared/src/index.ts:
  - AxialCoord, CubeCoord interfaces for hexagonal coordinates
  - PieceType type and Piece interface
  - Player interface
  - GameConfig interface
  - GamePhase type
  - GameState interface (the main shared type)
- Updated server to import GameState: `import { GameState } from '@jarls/shared'`
- Updated client to import GameState: `import { GameState } from '@jarls/shared'`
- Built shared package to generate dist folder with type declarations
- Verified `pnpm typecheck` passes for all packages
- Verified `pnpm test` passes for all packages

**Files Modified**:
- packages/shared/src/index.ts (added all core game types)
- packages/server/src/index.ts (added GameState import and usage)
- packages/client/src/App.tsx (added GameState import and usage)

---

### 2026-01-25: Infrastructure - ESLint Configuration

**Feature Completed**: "ESLint configured with TypeScript rules"

**Work Done**:
- Installed ESLint 9.x with TypeScript ESLint dependencies at workspace root:
  - eslint, @eslint/js, typescript-eslint
  - @typescript-eslint/parser, @typescript-eslint/eslint-plugin
- Created eslint.config.js using ESLint 9 flat config format
- Configured TypeScript-ESLint with recommended rules
- Added project service for type-aware linting
- Configured ignores for dist, node_modules, and generated JS files
- Updated root package.json:
  - Added `"type": "module"` for ESM support
  - Updated lint script to run ESLint on all package source files
- Verified `pnpm lint` runs successfully with no errors
- Verified `pnpm typecheck` still passes
- Verified `pnpm test` still passes

**Files Created**:
- eslint.config.js

**Files Modified**:
- package.json (added type:module, ESLint dependencies, updated lint script)

---

### 2026-01-25: Infrastructure - Prettier Configuration

**Feature Completed**: "Prettier configured for code formatting"

**Work Done**:
- Installed Prettier 3.x and eslint-config-prettier at workspace root
- Created .prettierrc with formatting rules:
  - Semi-colons enabled
  - Single quotes preferred
  - Tab width of 2 spaces
  - Trailing commas in ES5 contexts
  - Print width of 100 characters
  - LF line endings
- Created .prettierignore to exclude node_modules, dist, coverage, etc.
- Updated eslint.config.js to integrate eslint-config-prettier (disables conflicting rules)
- Updated root package.json:
  - Added format:check script for CI verification
- Ran `pnpm format` to format entire codebase
- Verified `pnpm format:check` passes (all files formatted)
- Verified `pnpm typecheck` still passes
- Verified `pnpm lint` still passes
- Verified `pnpm test` still passes

**Files Created**:
- .prettierrc
- .prettierignore

**Files Modified**:
- eslint.config.js (added eslint-config-prettier integration)
- package.json (added prettier, eslint-config-prettier dependencies, format:check script)

---

### 2026-01-25: Infrastructure - Git Hooks Configuration

**Feature Completed**: "Git hooks configured with Husky and lint-staged"

**Work Done**:
- Installed Husky 9.x and lint-staged 16.x at workspace root
- Ran `npx husky init` to initialize Husky:
  - Created .husky directory with pre-commit hook
  - Added `prepare` script to package.json for automatic Husky setup
- Configured pre-commit hook to run `npx lint-staged`
- Added lint-staged configuration to package.json:
  - TypeScript files (*.ts, *.tsx): runs ESLint with --fix, then Prettier
  - Other files (*.js, *.jsx, *.json, *.md, *.yml, *.yaml): runs Prettier
- Tested lint-staged directly with `npx lint-staged` - works correctly
- Verified `pnpm typecheck` still passes
- Verified `pnpm test` still passes

**Files Created**:
- .husky/pre-commit

**Files Modified**:
- package.json (added husky, lint-staged dependencies, prepare script, lint-staged config)

---

### 2026-01-25: Infrastructure - Jest Testing Configuration

**Feature Completed**: "Jest configured for testing"

**Work Done**:
- Installed Jest 30.x, ts-jest, @types/jest, and jest-environment-jsdom at workspace root
- Created jest.config.js using ESM export format with project references:
  - Separate project configurations for shared, server, and client packages
  - ts-jest configured with ESM support for TypeScript
  - jsdom test environment configured for client package (React testing)
  - Module name mappers for ESM compatibility and workspace package resolution
- Updated root package.json test script to run Jest with NODE_OPTIONS for ESM support
- Updated each package's test script to run Jest with --selectProjects for package-specific testing
- Created sample test file (packages/shared/src/index.test.ts) demonstrating test setup
- Test files use *.test.ts naming convention as required

**Verification**:
- `pnpm test` runs Jest successfully, finding and executing test files
- `pnpm typecheck` still passes for all packages
- `pnpm lint` still passes with no errors
- 2 tests passing in shared package

**Files Created**:
- jest.config.js
- packages/shared/src/index.test.ts

**Files Modified**:
- package.json (added jest, ts-jest, @types/jest, jest-environment-jsdom dependencies, updated test script)
- packages/shared/package.json (updated test script)
- packages/server/package.json (updated test script)
- packages/client/package.json (updated test script)

---

### 2026-01-25: Infrastructure - Server Hot-Reload Configuration

**Feature Completed**: "Server hot-reload configured with nodemon"

**Work Done**:
- Installed nodemon 3.x in the server package
- Created packages/server/nodemon.json with configuration:
  - Watches src directory for TypeScript file changes
  - Ignores test files (*.test.ts)
  - Uses tsx to execute TypeScript directly
- Updated packages/server/package.json:
  - Changed dev script from `tsx watch` to `nodemon`
- Added `"type": "module"` to packages/shared/package.json to fix ESM resolution for runtime imports
- Tested hot-reload: server starts correctly and logs output from @jarls/shared

**Verification**:
- `pnpm dev` (in packages/server) starts nodemon which executes tsx
- Server outputs "Jarls Server v0.1.0" and "Game state phase: lobby"
- nodemon watches for file changes and restarts automatically
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (2 tests in shared package)
- `pnpm lint` passes with no errors

**Files Created**:
- packages/server/nodemon.json

**Files Modified**:
- packages/server/package.json (added nodemon dependency, changed dev script)
- packages/shared/package.json (added type:module for ESM runtime support)

---

### 2026-01-25: Infrastructure - Client Hot-Reload Configuration

**Feature Completed**: "Client hot-reload configured with Vite"

**Work Done**:
- Verified Vite is already configured in client package with @vitejs/plugin-react
- Vite configuration includes React plugin which enables Fast Refresh (HMR) by default
- Added `dev:client` script to root package.json: `pnpm --filter @jarls/client dev`
- Also added `dev:server` script for consistency: `pnpm --filter @jarls/server dev`
- Tested Vite dev server starts correctly on http://localhost:5173/
- Verified HMR is working:
  - `/@react-refresh` is injected for React Fast Refresh
  - `/@vite/client` is loaded for Vite's HMR client
  - HMRContext class is properly initialized

**Verification**:
- `pnpm dev:client` starts Vite dev server successfully
- Server responds with HTML containing HMR scripts
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (2 tests in shared package)
- `pnpm lint` passes with no errors

**Files Modified**:
- package.json (added dev:client and dev:server scripts)

---

### 2026-01-25: Core Logic - HexDirection Type and DIRECTIONS Constant

**Feature Completed**: "HexDirection type and DIRECTIONS constant defined"

**Work Done**:
- Added HexDirection type (0-5) representing the 6 directions in a hexagonal grid
- Added DIRECTIONS constant array with all 6 direction vectors in cube coordinates
- Directions follow pointy-top hex orientation, counter-clockwise from East:
  - 0: East (q+1, r+0, s-1)
  - 1: Northeast (q+1, r-1, s+0)
  - 2: Northwest (q+0, r-1, s+1)
  - 3: West (q-1, r+0, s+1)
  - 4: Southwest (q-1, r+1, s+0)
  - 5: Southeast (q+0, r+1, s-1)
- Added comprehensive unit tests verifying:
  - Exactly 6 directions exist
  - All direction vectors satisfy cube coordinate constraint (q + r + s = 0)
  - All direction vectors are unit vectors (magnitude 2 in cube coords)
  - All directions are unique
  - Consistent hexagonal ordering (opposite directions are 3 apart)
  - HexDirection type works correctly as array index

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (8 tests total, 6 new tests for HexDirection/DIRECTIONS)

**Files Modified**:
- packages/shared/src/index.ts (added HexDirection type and DIRECTIONS constant)
- packages/shared/src/index.test.ts (added unit tests for HexDirection and DIRECTIONS)

---

### 2026-01-25: Core Logic - Coordinate Conversion Functions

**Feature Completed**: "axialToCube and cubeToAxial conversion functions work"

**Work Done**:
- Implemented `axialToCube(axial: AxialCoord): CubeCoord` function
  - Takes axial coordinates (q, r) and derives cube coordinates (q, r, s)
  - s component calculated from constraint q + r + s = 0
  - Handles -0 edge case by normalizing to 0
- Implemented `cubeToAxial(cube: CubeCoord): AxialCoord` function
  - Takes cube coordinates (q, r, s) and returns axial coordinates (q, r)
  - s component is discarded as it's redundant
- Added comprehensive unit tests:
  - Origin conversion tests
  - Positive and negative coordinate tests
  - Constraint verification (q + r + s = 0)
  - Round-trip conversion tests (axial -> cube -> axial)
  - Round-trip conversion tests (cube -> axial -> cube)

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (19 tests total, 11 new tests for conversion functions)

**Files Modified**:
- packages/shared/src/index.ts (added axialToCube and cubeToAxial functions)
- packages/shared/src/index.test.ts (added unit tests for conversion functions)

---

### 2026-01-25: Core Logic - Hex Distance Function

**Feature Completed**: "hexDistance function calculates correct distance"

**Work Done**:
- Implemented `hexDistance(a: CubeCoord, b: CubeCoord): number` function
  - Calculates shortest path length between two hexes using cube coordinates
  - Uses Manhattan distance formula: (|Δq| + |Δr| + |Δs|) / 2
- Implemented `hexDistanceAxial(a: AxialCoord, b: AxialCoord): number` function
  - Convenience wrapper that converts axial to cube coordinates internally
- Added comprehensive unit tests covering:
  - Distance from hex to itself is 0
  - Adjacent hexes have distance 1 (tested all 6 directions)
  - Hexes 2 steps away have distance 2
  - Hexes 3 steps away (board radius) have distance 3
  - Symmetry: distance(a, b) === distance(b, a)
  - Negative coordinates
  - Diagonal movement
  - Axial coordinate version matches cube version
  - Common game scenarios (edge to throne, opposite edges)

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (30 tests total, 11 new tests for hexDistance)

**Files Modified**:
- packages/shared/src/index.ts (added hexDistance and hexDistanceAxial functions)
- packages/shared/src/index.test.ts (added unit tests for hexDistance functions)

---

### 2026-01-25: Core Logic - Neighbor Functions

**Feature Completed**: "getNeighbor and getAllNeighbors functions work"

**Work Done**:
- Implemented `getNeighbor(hex: CubeCoord, direction: HexDirection): CubeCoord` function
  - Returns the adjacent hex in the specified direction
  - Uses DIRECTIONS array for direction vectors
- Implemented `getAllNeighbors(hex: CubeCoord): CubeCoord[]` function
  - Returns all 6 neighboring hexes around a given hex
  - Index corresponds to HexDirection (0=East, 1=NE, 2=NW, 3=West, 4=SW, 5=SE)
- Implemented `getNeighborAxial(hex: AxialCoord, direction: HexDirection): AxialCoord` function
  - Axial coordinate convenience wrapper
- Implemented `getAllNeighborsAxial(hex: AxialCoord): AxialCoord[]` function
  - Axial coordinate convenience wrapper
- Added comprehensive unit tests (25 new tests) covering:
  - All 6 directions individually verified
  - Cube coordinate constraint (q + r + s = 0) satisfied
  - All neighbors at distance 1
  - Negative coordinate handling
  - Inverse direction property (going East then West returns to origin)
  - Exactly 6 unique neighbors returned
  - Correct order matching DIRECTIONS array
  - Consistency between individual and batch calls
  - Consistency between cube and axial versions

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (55 tests total, 25 new tests for neighbor functions)

**Files Modified**:
- packages/shared/src/index.ts (added getNeighbor, getAllNeighbors, getNeighborAxial, getAllNeighborsAxial)
- packages/shared/src/index.test.ts (added unit tests for neighbor functions)

---

### 2026-01-25: Core Logic - getOppositeDirection Function

**Feature Completed**: "getOppositeDirection function returns correct opposite"

**Work Done**:
- Implemented `getOppositeDirection(direction: HexDirection): HexDirection` function
  - Returns the opposite direction (180 degrees) for any given hex direction
  - Uses formula `(direction + 3) % 6` since opposites are 3 apart in the array
  - Direction mappings: 0↔3 (East↔West), 1↔4 (NE↔SW), 2↔5 (NW↔SE)
- Added comprehensive unit tests (10 new tests) covering:
  - All 6 individual direction-to-opposite mappings verified
  - Self-inverse property (applying twice returns original)
  - Opposite direction vectors sum to zero (0, 0, 0)
  - Return value is valid HexDirection type (0-5)
  - Round-trip navigation test (move in direction, then opposite returns to origin)

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (65 tests total, 10 new tests for getOppositeDirection)

**Files Modified**:
- packages/shared/src/index.ts (added getOppositeDirection function)
- packages/shared/src/index.test.ts (added unit tests for getOppositeDirection)

---

### 2026-01-25: Core Logic - hexLine Function

**Feature Completed**: "hexLine function draws line between two hexes"

**Work Done**:
- Implemented `cubeRound(q, r, s): CubeCoord` helper function
  - Rounds fractional cube coordinates to nearest valid hex
  - Uses constraint q + r + s = 0 to ensure valid coordinates
  - Component with largest rounding error is recalculated
  - Normalizes -0 to 0 to avoid equality issues
- Implemented `hexLine(a: CubeCoord, b: CubeCoord): CubeCoord[]` function
  - Uses linear interpolation in cube coordinates with proper rounding
  - Returns array of all hexes along the line from a to b (inclusive)
  - Handles edge cases where line passes exactly between hexes via nudge offset
  - Returns distance + 1 hexes for any line
- Implemented `hexLineAxial(a, b): AxialCoord[]` convenience wrapper
- Added comprehensive unit tests (21 new tests) covering:
  - Single hex when start equals end
  - Two hexes for adjacent hexes
  - Start and end hexes included
  - Correct number of hexes (distance + 1)
  - Straight lines in all 6 directions (East, West, Northeast, etc.)
  - Cube coordinate constraint satisfied for all hexes
  - Consecutive hexes at distance 1
  - Diagonal lines
  - Lines with negative coordinates
  - Symmetry (line a→b equals reversed line b→a)
  - Edge cases where lines pass between hexes
  - Axial coordinate version consistency
  - Game scenario: Jarl to Throne path

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (86 tests total, 21 new tests for cubeRound/hexLine/hexLineAxial)

**Files Modified**:
- packages/shared/src/index.ts (added cubeRound, hexLine, hexLineAxial functions)
- packages/shared/src/index.test.ts (added unit tests for all new functions)

---

### 2026-01-25: Core Logic - isOnBoard and isOnEdge Functions

**Feature Completed**: "isOnBoard and isOnEdge functions validate positions"

**Work Done**:
- Implemented `isOnBoard(hex: CubeCoord, radius: number): boolean` function
  - Returns true if hex is within board bounds (distance from center <= radius)
  - Uses hexDistance to calculate distance from center (0,0,0)
- Implemented `isOnBoardAxial(hex: AxialCoord, radius: number): boolean` function
  - Axial coordinate convenience wrapper
- Implemented `isOnEdge(hex: CubeCoord, radius: number): boolean` function
  - Returns true if hex is exactly at the board edge (distance from center === radius)
- Implemented `isOnEdgeAxial(hex: AxialCoord, radius: number): boolean` function
  - Axial coordinate convenience wrapper
- Added comprehensive unit tests (25 new tests) covering:
  - Center hex (Throne) validation
  - Hexes within board radius
  - Hexes outside board radius
  - All 6 cardinal edge positions
  - Radius 0 (single hex board)
  - Different board sizes (radius 1, 3, 5)
  - Negative coordinate positions
  - Edge hex count verification (6r edge hexes for radius r)
  - Consistency between cube and axial versions
  - Game scenarios: Jarl starting positions, Throne position, pushed-off pieces
  - Boundary cases for hexes adjacent to edge

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (111 tests total, 25 new tests for isOnBoard/isOnEdge)

**Files Modified**:
- packages/shared/src/index.ts (added isOnBoard, isOnBoardAxial, isOnEdge, isOnEdgeAxial functions)
- packages/shared/src/index.test.ts (added unit tests for all new functions)

---

### 2026-01-25: Core Logic - hexToKey and keyToHex Functions

**Feature Completed**: "hexToKey and keyToHex enable Map storage"

**Work Done**:
- Implemented `hexToKey(hex: CubeCoord | AxialCoord): string` function
  - Converts hex coordinates to a unique string key for Map storage
  - Uses format "q,r" for minimal storage (axial coordinates)
  - Works with both cube and axial coordinate inputs
- Implemented `keyToHex(key: string): AxialCoord | null` function
  - Converts string key back to axial coordinates
  - Returns null for invalid keys (wrong format, non-numeric values)
- Implemented `keyToHexCube(key: string): CubeCoord | null` function
  - Convenience wrapper that returns cube coordinates
  - Calculates s component from constraint q + r + s = 0
- Added comprehensive unit tests (23 new tests) covering:
  - Origin conversion
  - Positive, negative, and mixed coordinates
  - Cube coordinate input (uses q, r only)
  - Unique keys for different hexes
  - Consistent keys for same hex
  - Invalid key handling (wrong format, non-numeric)
  - Round-trip conversions (axial and cube)
  - Map storage scenarios including game board piece tracking

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (134 tests total, 23 new tests for hexToKey/keyToHex)

**Files Modified**:
- packages/shared/src/index.ts (added hexToKey, keyToHex, keyToHexCube functions)
- packages/shared/src/index.test.ts (added unit tests for all new functions)

---

### 2026-01-25: Core Logic - Game State Types Fully Defined

**Feature Completed**: "Game state types fully defined"

**Work Done**:
- Added MoveCommand interface for player move inputs:
  - pieceId: string to identify the piece being moved
  - destination: AxialCoord for the target position
- Added CombatBreakdown interface for attack/defense calculation details:
  - baseStrength, momentum, support, total breakdown
- Added CombatResult interface for combat preview:
  - attackerId, defenderId, attack/defense breakdowns
  - outcome ('push' | 'blocked'), pushDirection
- Added ValidMove interface for move validation:
  - destination, moveType ('move' | 'attack'), hasMomentum
  - combatPreview for attack moves
- Added MoveResult interface for move execution results:
  - success, error (optional), newState, events array
- Added GameEvent union type with all event types:
  - MoveEvent: piece movement tracking
  - PushEvent: push chain tracking with depth for animations
  - EliminatedEvent: piece elimination (edge or starvation)
  - TurnEndedEvent: turn transitions
  - GameEndedEvent: game conclusion with winner/condition
  - StarvationTriggeredEvent: starvation mechanic activation
  - StarvationResolvedEvent: starvation resolution
  - PlayerJoinedEvent, PlayerLeftEvent: lobby events
- All types properly exported from @jarls/shared

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (134 tests)

**Files Modified**:
- packages/shared/src/index.ts (added MoveCommand, CombatBreakdown, CombatResult, ValidMove, MoveResult, GameEvent and all individual event types)

---

### 2026-01-25: Core Logic - getConfigForPlayerCount Function

**Feature Completed**: "getConfigForPlayerCount returns correct scaling"

**Work Done**:
- Implemented `getConfigForPlayerCount(playerCount, turnTimerMs?)` function
  - Returns GameConfig object with scaling values from the ruleset
  - Supports 2-6 players with appropriate board radius, shield count, and warrior count
- Added PLAYER_SCALING constant with scaling table from ruleset:
  - 2 players: radius 3, 5 shields, 5 warriors (37 hexes, ~32% density)
  - 3 players: radius 5, 4 shields, 5 warriors (91 hexes, ~20% density)
  - 4 players: radius 6, 4 shields, 4 warriors (127 hexes, ~16% density)
  - 5 players: radius 7, 3 shields, 4 warriors (169 hexes, ~15% density)
  - 6 players: radius 8, 3 shields, 4 warriors (217 hexes, ~14% density)
- Function validates player count and throws error for invalid values (< 2 or > 6)
- Optional turnTimerMs parameter defaults to null (no timer)
- Added comprehensive unit tests (22 new tests) covering:
  - All player counts (2-6) with correct scaling values
  - Total hex count verification using formula 3r² + 3r + 1
  - Turn timer configurations (null, 30s, 60s, 120s)
  - Invalid player count error handling
  - Return type verification
  - Density scaling verification (decreasing density as player count increases)

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (156 tests total, 22 new tests for getConfigForPlayerCount)

**Files Modified**:
- packages/shared/src/index.ts (added PLAYER_SCALING constant and getConfigForPlayerCount function)
- packages/shared/src/index.test.ts (added unit tests for getConfigForPlayerCount)

---

### 2026-01-25: Core Logic - generateAllBoardHexes Function Verified

**Feature Completed**: "generateAllBoardHexes creates correct hex count"

**Work Done**:
- Verified existing implementation of `getBoardHexCount(radius)` function
  - Calculates total hexes using formula: 3r² + 3r + 1
  - Returns correct counts for all board sizes (1, 7, 19, 37, 91, 127, 169, 217)
- Verified existing implementation of `generateAllBoardHexes(radius)` function
  - Generates array of all valid CubeCoord positions for given radius
  - Iterates through q/r coordinates and derives s from constraint q + r + s = 0
  - Returns hexes in consistent order (by q, then by r)
- Verified existing implementation of `generateAllBoardHexesAxial(radius)` function
  - Convenience wrapper returning AxialCoord array
- Existing tests (27 tests) verify:
  - Radius 3 generates exactly 37 hexes
  - Formula 3r² + 3r + 1 verified for all standard board sizes
  - All hexes satisfy cube coordinate constraint (q + r + s = 0)
  - All hexes within board radius (isOnBoard returns true)
  - All unique hexes generated
  - Complete coverage (includes center/Throne, all edge hexes, all distances)
  - Consistency between cube and axial versions

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (183 tests total, 27 tests for getBoardHexCount/generateAllBoardHexes)

**Files Verified** (already existed):
- packages/shared/src/index.ts (getBoardHexCount, generateAllBoardHexes, generateAllBoardHexesAxial at lines 519-579)
- packages/shared/src/index.test.ts (tests at lines 1483-1719)

---

### 2026-01-25: Core Logic - calculateStartingPositions Function

**Feature Completed**: "calculateStartingPositions places Jarls equidistantly"

**Work Done**:
- Implemented `hexToPixel(hex, size)` helper function
  - Converts axial hex coordinates to pixel coordinates for rendering
  - Uses pointy-top hex orientation
  - Returns center point of the hex as { x, y }
- Implemented `hexToAngle(hex)` helper function
  - Calculates angle (in radians) from board center to a hex
  - Angle 0 is East, increasing counter-clockwise
  - Used for angular positioning of starting positions
- Implemented `calculateStartingPositions(playerCount, radius)` function
  - Returns array of AxialCoord positions, one per player
  - All Jarls start on edge hexes (distance from center = radius)
  - Jarls are positioned at evenly-spaced angles around the board
  - For N players: angles at 0, 2π/N, 4π/N, ..., (N-1)*2π/N radians
  - For 2 players: directly opposite edges (East and West)
  - Validates player count (2-6) and throws error for invalid values
- Added comprehensive unit tests (34 new tests) covering:
  - 2-player positions: exactly 2, opposite edges, equidistant from center
  - 3-player positions: exactly 3, all on edge, equidistant, spread angularly
  - All player counts (2-6): unique positions, all on edge, all equidistant from Throne
  - Error handling: invalid player counts (0, 1, 7, negative)
  - Position validity: all on board, none on Throne

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (217 tests total, 34 new tests for hexToPixel/hexToAngle/calculateStartingPositions)

**Files Modified**:
- packages/shared/src/index.ts (added hexToPixel, hexToAngle, calculateStartingPositions functions)
- packages/shared/src/index.test.ts (added unit tests for all new functions)

---

### 2026-01-25: Core Logic - generateSymmetricalShields Function

**Feature Completed**: "generateSymmetricalShields places shields fairly"

**Work Done**:
- Implemented `rotateHex(hex, steps)` helper function:
  - Rotates a hex position around the board center by 60-degree steps
  - Used for generating rotationally symmetric shield positions
  - Preserves distance from center and cube coordinate constraint
- Implemented `generateSymmetricalShields(playerCount, radius, shieldCount)` function:
  - Places shields with N-fold rotational symmetry (where N = playerCount)
  - Groups hexes by their "canonical" form under rotation to find symmetric positions
  - Prioritizes complete symmetric groups for fair gameplay
  - Falls back to partial placement when full symmetry isn't achievable
  - Shields are equidistant from all starting positions due to rotational symmetry
- Position constraints enforced:
  - No shield on the Throne (center hex at 0,0)
  - No shield on edge hexes (where pieces start and can be pushed off)
  - All shields placed in interior hexes (0 < distance < radius)
- Added comprehensive unit tests (25 new tests) covering:
  - Basic functionality: correct shield count for all player configurations
  - Position constraints: not on Throne, not on edge, within board, interior only
  - Rotational symmetry: shields have symmetric partners under rotation
  - Equidistance: balanced distance sums to starting positions
  - Error handling: invalid player counts, insufficient space
  - Game scenarios: all standard configurations (2-6 players)

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (242 tests total, 25 new tests for rotateHex/generateSymmetricalShields)
- `pnpm lint` passes with no errors

**Files Modified**:
- packages/shared/src/index.ts (added rotateHex and generateSymmetricalShields functions)
- packages/shared/src/index.test.ts (added unit tests for new functions)

---

### 2026-01-25: Core Logic - validateShieldPlacement Function

**Feature Completed**: "validateShieldPlacement ensures path to Throne"

**Work Done**:
- Implemented `hasPathToThrone(startPosition, shieldPositions, radius)` function:
  - Checks if there's an unobstructed straight-line path from a starting position to the Throne
  - Uses `hexLineAxial` to get all hexes on the straight line from start to center
  - Returns true if no shields block any hex along the path (excluding start and end)
- Implemented `validateShieldPlacement(shieldPositions, startingPositions, radius)` function:
  - Validates that all players have at least one unobstructed path to the Throne
  - Returns object with `isValid` boolean and `blockedPlayers` array
  - `blockedPlayers` contains indices of players whose paths are all blocked
  - Uses Set for O(1) shield position lookups
- Added comprehensive unit tests (21 new tests) covering:
  - Basic path detection: clear paths, blocked paths
  - Various starting positions: West edge, Northeast area, Southwest area
  - Throne adjacency scenarios
  - Valid placement detection: no shields, non-blocking shields
  - Invalid placement detection: player 0 blocked, player 1 blocked, all blocked
  - Result structure validation for all player configurations (2-6)

**Note**: The current `generateSymmetricalShields` function may produce placements that block
some paths. This is expected behavior - the `validateShieldPlacement` function correctly
identifies these invalid placements, allowing the game setup process to regenerate shields
when needed.

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (263 tests total, 21 new tests for hasPathToThrone/validateShieldPlacement)
- `pnpm lint` passes with no errors

**Files Modified**:
- packages/shared/src/index.ts (added hasPathToThrone and validateShieldPlacement functions)
- packages/shared/src/index.test.ts (added unit tests for new functions)

---

### 2026-01-25: Core Logic - placeWarriors Function

**Feature Completed**: "placeWarriors positions Warriors in front of Jarl"

**Work Done**:
- Implemented `getDirectionTowardThrone(startPosition)` helper function:
  - Finds the hex direction that most closely points from a starting position toward the Throne
  - Used to determine which direction Warriors should be placed (in front of the Jarl)
  - Returns the HexDirection (0-5) that minimizes distance to the Throne when moving from the start position
- Implemented `placeWarriors(jarlPosition, warriorCount, shieldPositions, radius)` function:
  - Places Warriors between the Jarl and the Throne in a line formation
  - Uses `hexLineAxial` to get hexes on the direct path from Jarl to Throne
  - Warriors are placed on available hexes along the path, skipping shields and the Throne
  - If direct path is blocked by shields, falls back to adjacent hexes prioritizing the direction toward the Throne
  - Respects all placement constraints: no overlap with Jarl, shields, or Throne
- Added comprehensive unit tests (21 new tests) covering:
  - Basic placement: correct count, zero/negative counts, unique positions
  - Position constraints: not on Jarl, not on Throne, not on shields, within board bounds
  - Formation toward throne: warriors placed between Jarl and Throne, line formation when path is clear
  - Shield avoidance: places warriors around shields, finds alternate positions when path blocked
  - Game scenarios: standard 2-player configurations, diagonal positions, full game setup with shields

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (284 tests total, 21 new tests for getDirectionTowardThrone/placeWarriors)

**Files Modified**:
- packages/shared/src/index.ts (added getDirectionTowardThrone and placeWarriors functions)
- packages/shared/src/index.test.ts (added unit tests for new functions)

---

### 2026-01-25: Core Logic - createInitialState Function

**Feature Completed**: "createInitialState generates complete game state"

**Work Done**:
- Implemented `generateId()` helper function:
  - Generates unique IDs for game entities using timestamp + random string
  - Used for game ID, player IDs, and piece IDs
- Implemented `createInitialState(playerNames, turnTimerMs?)` function:
  - Creates a complete GameState object ready for gameplay
  - Accepts array of player names (2-6 players) and optional turn timer
  - Creates Player objects with unique IDs, names, and distinct colors
  - Calculates Jarl starting positions using `calculateStartingPositions`
  - Generates shield positions using `generateSymmetricalShields` with path validation
  - Places Jarls on edge hexes at starting positions
  - Places Warriors in front of each Jarl using `placeWarriors`
  - Sets game phase to 'setup'
  - Initializes all counters (turnNumber, roundNumber, roundsSinceElimination) to 0
  - Sets first player as currentPlayerId
- Enhanced `generateSymmetricalShields` to accept optional starting positions:
  - Avoids placing shields on direct paths from starting positions to Throne
  - Ensures valid shield placements that don't block all paths for any player
- Added PLAYER_COLORS constant for up to 6 distinct player colors
- Added comprehensive unit tests (36 new tests) covering:
  - Basic creation: all required fields, unique IDs, initial counters
  - Player initialization: correct count, names, unique IDs, distinct colors, not eliminated
  - Configuration: correct config for player counts, turn timer handling
  - Piece placement: correct counts, positions, player assignments, uniqueness
  - Error handling: invalid player counts
  - Game scenarios: all supported player counts, consistent structure, proper Warrior positioning

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (320 tests total, 36 new tests for generateId/createInitialState)

**Files Modified**:
- packages/shared/src/index.ts (added PLAYER_COLORS, generateId, createInitialState; enhanced generateSymmetricalShields)
- packages/shared/src/index.test.ts (added unit tests for generateId and createInitialState)

---

### 2026-01-25: Core Logic - getPieceAt and getPieceById Helper Functions

**Feature Completed**: "getPieceAt and getPieceById helpers work"

**Work Done**:
- Implemented `getPieceAt(state, position)` function:
  - Returns the piece at a specific position on the board
  - Returns undefined if no piece exists at the given position
  - Uses `hexToKey` for efficient position comparison
- Implemented `getPieceById(state, pieceId)` function:
  - Returns the piece with the specified unique ID
  - Returns undefined if no piece with the given ID exists
- Both functions handle edge cases gracefully:
  - Empty pieces array returns undefined
  - Off-board positions return undefined
  - Non-existent IDs return undefined
- Added comprehensive unit tests (19 new tests) covering:
  - Basic piece retrieval by position and ID
  - Finding Jarls, Warriors, and Shields correctly
  - Handling missing pieces (undefined return)
  - Empty state handling
  - Verifying correct piece object reference is returned
  - Testing across different player counts (2-6)

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (339 tests total, 19 new tests for getPieceAt/getPieceById)

**Files Modified**:
- packages/shared/src/index.ts (added getPieceAt and getPieceById functions)
- packages/shared/src/index.test.ts (added unit tests for getPieceAt and getPieceById)

---

### 2026-01-26: Core Logic - isPathClear Function

**Feature Completed**: "isPathClear checks for blocking pieces"

**Work Done**:
- Implemented `isPathClear(state, start, end)` function:
  - Checks if a path between two hexes is clear of pieces
  - Returns true when path has no pieces blocking it
  - Returns false when any piece exists on the path
  - Checks all hexes between start and end (exclusive of both endpoints)
  - Uses `hexLineAxial` to get hexes along the path
  - Uses `getPieceAt` to check for pieces at each intermediate hex
- This function is used to validate moves - pieces cannot move through other pieces
- Added comprehensive unit tests (23 new tests) covering:
  - Returns true when path has no pieces (empty board, pieces not on path)
  - Returns true when piece is at start/end position (endpoints not checked)
  - Returns false when piece blocks path (warrior, shield, jarl)
  - Returns false when multiple pieces block path
  - Returns false when friendly piece blocks path
  - Checks first hex after start and last hex before end
  - Works with diagonal paths and negative coordinates
  - Edge cases: same position, adjacent hexes, all 6 directions
  - Game scenarios: blocked paths in actual game states

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (362 tests total, 23 new tests for isPathClear)

**Files Modified**:
- packages/shared/src/index.ts (added isPathClear function)
- packages/shared/src/index.test.ts (added unit tests for isPathClear)

---

### 2026-01-26: Core Logic - hasDraftFormation Function

**Feature Completed**: "hasDraftFormation detects 2+ Warriors behind Jarl"

**Work Done**:
- Implemented `hasDraftFormationInDirection(state, jarlPosition, playerId, movementDirection)` function:
  - Checks if there are 2+ friendly Warriors behind the Jarl in a straight line
  - "Behind" means in the opposite direction of the intended movement
  - Warriors don't need to be consecutive - gaps between them are allowed
  - Enemy pieces and shields block the draft line
  - Stops searching when hitting board edge
- Implemented `hasDraftFormation(state, jarlPosition, playerId)` function:
  - Checks all 6 directions to find where draft movement is possible
  - Returns array of HexDirection values where Jarl can make 2-hex draft moves
  - Empty array means Jarl can only move 1 hex
- Both functions are used to enable the Jarl's special 2-hex movement ability when backed by Warriors
- Added comprehensive unit tests (20 new tests) covering:
  - Returns true with 2 consecutive Warriors behind
  - Returns true with 2 non-consecutive Warriors in line (gaps allowed)
  - Returns false with only 1 Warrior behind
  - Returns false with no Warriors behind
  - Returns false when enemy Warrior is in the line
  - Returns false when shield blocks the line
  - Checks correct direction (opposite of movement)
  - Returns false when Warriors are in front, not behind
  - Handles Jarl near board edge
  - Returns false when off board before finding 2 Warriors
  - Main function returns empty array, single direction, or multiple directions
  - Gap scenarios with 1 or 2 empty hexes between Warriors
  - Works with real game states

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (382 tests total, 20 new tests for hasDraftFormation)

**Files Modified**:
- packages/shared/src/index.ts (added hasDraftFormationInDirection and hasDraftFormation functions)
- packages/shared/src/index.test.ts (added unit tests for hasDraftFormation functions)

---

### 2026-01-26: Core Logic - validateMove Function

**Feature Completed**: "validateMove checks all move rules"

**Work Done**:
- Implemented `MoveValidationError` type with all error cases:
  - PIECE_NOT_FOUND, NOT_YOUR_PIECE, NOT_YOUR_TURN, GAME_NOT_PLAYING
  - DESTINATION_OFF_BOARD, DESTINATION_OCCUPIED_FRIENDLY, WARRIOR_CANNOT_ENTER_THRONE
  - INVALID_DISTANCE_WARRIOR, INVALID_DISTANCE_JARL, JARL_NEEDS_DRAFT_FOR_TWO_HEX
  - PATH_BLOCKED, MOVE_NOT_STRAIGHT_LINE, SHIELD_CANNOT_MOVE
- Implemented `MoveValidation` interface with isValid, error, and hasMomentum fields
- Implemented `getDirectionBetweenAdjacent(from, to)` helper function:
  - Returns the HexDirection between two adjacent hexes
  - Returns null if hexes are not adjacent
- Implemented `getLineDirection(from, to)` helper function:
  - Returns the HexDirection if two hexes are in a straight line
  - Returns null if hexes are not in a straight line
  - Handles all 6 hex directions and same-position case
- Implemented `validateMove(state, playerId, command)` main validation function:
  - Validates piece exists and belongs to player
  - Validates it's player's turn
  - Validates game is in 'playing' phase
  - Validates destination is on board
  - Validates destination is not occupied by friendly piece
  - Validates Warriors cannot enter Throne
  - Validates move is in a straight line
  - Validates distance is correct for piece type (Warriors: 1-2, Jarls: 1 or 2 with draft)
  - Validates Jarl draft requirement for 2-hex moves
  - Validates path is clear (no pieces blocking)
  - Returns hasMomentum flag for 2-hex moves
- Added comprehensive unit tests (41 new tests) covering:
  - getDirectionBetweenAdjacent: all 6 directions, non-adjacent, same hex
  - getLineDirection: all 6 axes, non-straight-line, same position
  - validateMove: piece existence, ownership, turn order, game phase, distance validation,
    path clear, draft formation, throne restriction, friendly piece blocking, off-board,
    straight-line moves, shield restriction, momentum flag, realistic game scenarios

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (423 tests total, 41 new tests for validateMove and helpers)

**Files Modified**:
- packages/shared/src/index.ts (added MoveValidationError, MoveValidation, getDirectionBetweenAdjacent, getLineDirection, validateMove)
- packages/shared/src/index.test.ts (added unit tests for all new functions)

---

### 2026-01-26: Core Logic - findInlineSupport Function

**Feature Completed**: "findInlineSupport finds pieces behind attacker"

**Work Done**:
- Implemented `InlineSupportResult` interface:
  - `pieces`: Array of pieces directly behind the attacker in the support line
  - `totalStrength`: Sum of individual piece strengths
- Implemented `getPieceStrength(piece)` helper function:
  - Returns 2 for Jarl, 1 for Warrior, 0 for Shield
  - Used for calculating attack/defense power
- Implemented `findInlineSupport(state, attackerPosition, attackerId, attackDirection)` function:
  - Finds all friendly pieces directly behind the attacker in a continuous line
  - Support comes from the opposite direction of the attack
  - Collects pieces in order from closest to furthest behind attacker
  - Stops collecting at first empty hex (support line must be continuous)
  - Stops collecting at enemy piece or shield
  - Stops collecting at board edge
  - Sums strength of all supporting pieces (Warrior: 1, Jarl: 2)
- Added comprehensive unit tests (23 new tests) covering:
  - Basic functionality: no support, single Warrior, multiple Warriors, Jarl support (strength 2), mixed piece types
  - Stops at empty hex: gap in support line, empty hex directly behind
  - Stops at enemy piece: enemy blocks line, enemy directly behind
  - Stops at shield: shield blocks line, shield directly behind
  - Stops at board edge: support at edge, no room behind
  - Different attack directions: Northeast, West, Southeast (all 6 directions work)
  - Pieces not in support line ignored: adjacent but not in line, in front instead of behind
  - Game scenarios: realistic attack with Jarl+Warrior support, actual initial game state

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (446 tests total, 23 new tests for getPieceStrength/findInlineSupport)

**Files Modified**:
- packages/shared/src/index.ts (added InlineSupportResult, getPieceStrength, findInlineSupport)
- packages/shared/src/index.test.ts (added unit tests for getPieceStrength and findInlineSupport)

---

### 2026-01-26: Core Logic - findBracing Function

**Feature Completed**: "findBracing finds pieces behind defender"

**Work Done**:
- Implemented `BracingResult` interface:
  - `pieces`: Array of pieces directly behind the defender in the bracing line
  - `totalStrength`: Sum of individual piece strengths
- Implemented `findBracing(state, defenderPosition, defenderId, pushDirection)` function:
  - Finds all friendly pieces directly behind the defender in the push direction
  - Bracing pieces resist the push by adding to defense strength
  - Collects pieces in order from closest to furthest behind defender
  - Stops collecting at first empty hex (bracing line must be continuous)
  - Stops collecting at enemy piece or shield
  - Stops collecting at board edge
  - Sums strength of all bracing pieces (Warrior: 1, Jarl: 2)
- This is the defensive counterpart to `findInlineSupport` (which is for attackers)
- Added comprehensive unit tests (20 new tests) covering:
  - Basic functionality: no bracing, single Warrior, multiple Warriors, Jarl bracing (strength 2), mixed piece types
  - Stops at empty hex: gap in bracing line, empty hex directly behind
  - Stops at enemy piece: enemy blocks line, enemy directly behind
  - Stops at shield: shield blocks line, shield directly behind
  - Stops at board edge: bracing at edge, no room behind
  - Different push directions: Northeast, West, Southeast (all 6 directions work)
  - Pieces not in bracing line ignored: adjacent but not in line, opposite direction of push
  - Game scenarios: realistic defense with Jarl+Warrior bracing, actual initial game state

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (466 tests total, 20 new tests for findBracing)

**Files Modified**:
- packages/shared/src/index.ts (added BracingResult interface and findBracing function)
- packages/shared/src/index.test.ts (added unit tests for findBracing)

---

### 2026-01-26: Core Logic - calculateAttack Function

**Feature Completed**: "calculateAttack computes total attack power"

**Work Done**:
- Implemented `calculateAttack(state, attacker, attackerPosition, attackDirection, hasMomentum)` function:
  - Calculates total attack power using formula: Base Strength + Momentum + Inline Support
  - Base strength: 1 for Warrior, 2 for Jarl (uses existing `getPieceStrength` function)
  - Momentum bonus: +1 if attacker moved 2 hexes to reach defender
  - Inline support: Sum of strength of all friendly pieces behind attacker (uses existing `findInlineSupport` function)
  - Returns `CombatBreakdown` object with `baseStrength`, `momentum`, `support`, and `total` fields
- Function takes `attackerPosition` parameter (where attacker will be when attacking) to properly calculate support from that position
- Added comprehensive unit tests (17 new tests) covering:
  - Base strength: Warrior (1), Jarl (2)
  - Momentum bonus: +1 when hasMomentum is true, 0 otherwise
  - Inline support: single piece, Jarl support (strength 2), multiple pieces, enemy pieces ignored
  - Combined calculation: base + momentum + support totals correctly
  - Different attack directions: Northeast, West (all 6 directions work)
  - Game scenarios: actual initial game state, attacker position different from piece position

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (483 tests total, 17 new tests for calculateAttack)

**Files Modified**:
- packages/shared/src/index.ts (added calculateAttack function)
- packages/shared/src/index.test.ts (added unit tests for calculateAttack)

---

### 2026-01-26: Core Logic - calculateDefense Function

**Feature Completed**: "calculateDefense computes total defense power"

**Work Done**:
- Implemented `calculateDefense(state, defender, defenderPosition, pushDirection)` function:
  - Calculates total defense power using formula: Base Strength + Bracing
  - Base strength: 1 for Warrior, 2 for Jarl (uses existing `getPieceStrength` function)
  - Momentum is always 0 for defenders (attackers-only bonus)
  - Bracing: Sum of strength of friendly pieces behind defender in push direction (uses existing `findBracing` function)
  - Returns `CombatBreakdown` object with `baseStrength`, `momentum` (always 0), `support` (bracing), and `total` fields
- This is the defensive counterpart to `calculateAttack` (which computes attack power)
- Added comprehensive unit tests (16 new tests) covering:
  - Base strength: Warrior (1), Jarl (2)
  - No momentum: always 0 for defense
  - Bracing support: single piece, Jarl bracing (strength 2), multiple pieces, enemy pieces ignored, gaps break line
  - Combined calculation: base + bracing totals correctly, correct breakdown structure
  - Different push directions: Northeast, West (all 6 directions work)
  - Game scenarios: actual initial game state, shield wall formation

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (499 tests total, 16 new tests for calculateDefense)

**Files Modified**:
- packages/shared/src/index.ts (added calculateDefense function)
- packages/shared/src/index.test.ts (added unit tests for calculateDefense)

---

### 2026-01-26: Core Logic - calculateCombat Function

**Feature Completed**: "calculateCombat returns full CombatResult"

**Work Done**:
- Implemented `calculateCombat(state, attacker, attackerPosition, defender, defenderPosition, attackDirection, hasMomentum)` function:
  - Returns full CombatResult object used for combat preview
  - Calculates attack power using existing `calculateAttack` function
  - Calculates defense power using existing `calculateDefense` function
  - Determines combat outcome: 'push' if attack > defense, 'blocked' if attack <= defense
  - Returns pushDirection when push succeeds, null when blocked
  - Includes attackerId and defenderId for UI reference
- Added comprehensive unit tests (21 new tests) covering:
  - Returns attack and defense values with all breakdown components
  - Attack/defense breakdowns include support, momentum, and base strength
  - Combat outcome: push when attack > defense, blocked when attack <= defense
  - Push direction: returned when push succeeds, null when blocked
  - Includes attacker and defender IDs
  - Complex combat scenarios: Jarl vs Jarl, momentum effects, multiple support/bracing pieces
  - Used for combat preview: provides all information needed for UI

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (520 tests total, 21 new tests for calculateCombat)

**Files Modified**:
- packages/shared/src/index.ts (added calculateCombat function)
- packages/shared/src/index.test.ts (added unit tests for calculateCombat)

---

### 2026-01-26: Core Logic - detectChain Function

**Feature Completed**: "detectChain identifies all pieces in push chain"

**Work Done**:
- Implemented `ChainTerminator` type: 'edge' | 'shield' | 'throne' | 'empty'
- Implemented `ChainResult` interface:
  - `pieces`: Array of pieces in the chain, ordered from first pushed to last
  - `terminator`: What terminates the chain (edge, shield, throne, or empty)
  - `terminatorPosition`: The position where the chain ends
- Implemented `detectChain(state, startPosition, pushDirection)` function:
  - Walks along the push direction starting from the defender's position
  - Collects all pieces (Jarls and Warriors) in the chain regardless of allegiance
  - Stops when hitting a chain terminator:
    - Empty hex: pieces can compress into this space
    - Board edge: piece at end will be eliminated
    - Shield: pieces compress against it (shields don't move)
    - Throne: pieces compress against it (special handling for Jarls)
  - Returns pieces in order from first pushed to last
  - Handles mixed allegiance chains (friendly and enemy pieces together)
- Added comprehensive unit tests (21 new tests) covering:
  - Single piece chains and multi-piece chains
  - Pieces ordered correctly from first to last
  - All four terminator types (edge, shield, throne, empty)
  - Mixed allegiance chains with alternating players
  - Different push directions (all 6 directions)
  - Edge cases: empty starting position, shield immediately behind, long chains
  - Game scenarios: typical combat, Jarl toward throne, elimination chains

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (541 tests total, 21 new tests for detectChain)

**Files Modified**:
- packages/shared/src/index.ts (added ChainTerminator, ChainResult, detectChain)
- packages/shared/src/index.test.ts (added unit tests for detectChain)

---

### 2026-01-26: Core Logic - resolveSimplePush Function

**Feature Completed**: "resolveSimplePush moves piece to empty hex"

**Work Done**:
- Implemented `SimplePushResult` interface:
  - `newState`: The game state after the push is applied
  - `events`: Array of GameEvent objects generated by the push
- Implemented `resolveSimplePush(state, attackerId, attackerFrom, defenderPosition, pushDirection, hasMomentum)` function:
  - Handles the simplest push scenario: defender pushed to an empty hex
  - Defender moves one hex in the push direction
  - Attacker takes the defender's original position
  - Generates MOVE event for attacker (with correct from/to and hasMomentum flag)
  - Generates PUSH event for defender (with from/to, pushDirection, and depth=0)
  - Creates immutable new state (doesn't modify original)
  - Preserves all other pieces unchanged
  - Includes error handling for missing attacker or defender
- Added comprehensive unit tests (20 new tests) covering:
  - Defender movement: all 6 push directions (East, West, Northeast, etc.)
  - Defender types: Warriors and Jarls
  - Attacker takes defender's position correctly
  - Momentum scenarios (1-hex and 2-hex moves)
  - Event generation: MOVE and PUSH events with correct properties
  - PUSH event depth is 0 (first piece in chain)
  - State immutability: original state not modified
  - Other pieces preserved unchanged
  - Error handling: invalid attacker ID, empty defender position
  - Game scenarios: realistic combat situations

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (561 tests total, 20 new tests for resolveSimplePush)

**Files Modified**:
- packages/shared/src/index.ts (added SimplePushResult interface and resolveSimplePush function)
- packages/shared/src/index.test.ts (added unit tests for resolveSimplePush)

---

### 2026-01-26: Core Logic - resolveEdgePush Function

**Feature Completed**: "resolveEdgePush eliminates pieces at edge"

**Work Done**:
- Implemented `EdgePushResult` interface:
  - `newState`: The game state after the push (with eliminated pieces removed)
  - `events`: Array of GameEvent objects generated by the push
  - `eliminatedPieceIds`: Array of IDs of pieces that were eliminated
- Implemented `resolveEdgePush(state, attackerId, attackerFrom, defenderPosition, pushDirection, hasMomentum, chain)` function:
  - Handles push resolution when the chain terminates at the board edge
  - Piece at the edge is removed from the game (eliminated)
  - Chain compresses toward the edge: each surviving piece moves one position in push direction
  - Generates MOVE event for attacker (placed first in events array for proper ordering)
  - Generates PUSH events for each surviving chain piece with correct depth for staggered animation
  - Generates ELIMINATED event for the piece pushed off the edge (cause: 'edge')
  - Attacker takes the first defender's original position after compression
  - Creates immutable new state (doesn't modify original)
  - Validates chain terminator is 'edge' and attacker exists
- Added comprehensive unit tests (17 new tests) covering:
  - Single piece elimination: piece at edge eliminated, attacker takes position
  - ELIMINATED event generation with correct pieceId, playerId, position, and cause
  - MOVE event generation with correct from/to and hasMomentum flag
  - Chain compression: 2-piece chain, 3-piece chain with correct position shifts
  - PUSH events with correct depth for animation staggering
  - Mixed allegiance chains: alternating player pieces handled correctly
  - Different push directions: East, West, Northeast, Southeast
  - Jarl elimination: Jarl pushed off edge is eliminated with correct event
  - State immutability: original state not modified, bystander pieces preserved
  - Error handling: missing attacker, non-edge terminator
  - Event ordering: MOVE event comes before PUSH and ELIMINATED events
  - Game scenarios: typical combat at edge with momentum

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (578 tests total, 17 new tests for resolveEdgePush)

**Files Modified**:
- packages/shared/src/index.ts (added EdgePushResult interface and resolveEdgePush function)
- packages/shared/src/index.test.ts (added unit tests for resolveEdgePush)

---

### 2026-01-26: Core Logic - resolveCompression Function

**Feature Completed**: "resolveCompression handles shield and throne blocking"

**Work Done**:
- Implemented `CompressionResult` interface:
  - `newState`: The game state after compression (no pieces eliminated)
  - `events`: Array of GameEvent objects generated by the compression
- Implemented `resolveCompression(state, attackerId, attackerFrom, defenderPosition, pushDirection, hasMomentum, chain)` function:
  - Handles push resolution when the chain terminates at a shield or throne
  - Pieces compress against the immovable blocker - no pieces are eliminated
  - Chain pieces shift one position toward the blocker when possible
  - Pieces adjacent to the blocker cannot move (they stay in place)
  - Attacker takes the first defender's original position
  - Generates MOVE event for attacker (placed first for proper event ordering)
  - Generates PUSH events for chain pieces that can move (with depth for animation staggering)
  - No PUSH events generated for pieces that cannot move (adjacent to blocker)
  - Creates immutable new state (doesn't modify original)
  - Validates chain terminator is 'shield' or 'throne'
- This handles:
  - Shield blocking: pieces compress against an immovable shield
  - Throne blocking: Warriors compress against throne (they can't enter)
  - Jarl compression against throne when pushed (Jarls cannot be pushed onto throne)
- Added comprehensive unit tests (19 new tests) covering:
  - Shield compression: single piece, multiple pieces, no elimination
  - Throne compression: Warrior compression, Jarl compression, no victory trigger
  - Event generation: MOVE event for attacker, PUSH events for moving pieces, no PUSH for blocked pieces
  - State immutability: original state not modified, bystander pieces preserved
  - Error handling: missing attacker, invalid terminator (edge, empty)
  - Different push directions: West against shield, West against throne, Southeast against shield
  - Mixed allegiance chains: friendly and enemy pieces in same chain
  - Game scenarios: typical combat with shield blocking

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (597 tests total, 19 new tests for resolveCompression)

**Files Modified**:
- packages/shared/src/index.ts (added CompressionResult interface and resolveCompression function)
- packages/shared/src/index.test.ts (added unit tests for resolveCompression)

---

### 2026-01-26: Core Logic - resolvePush Main Resolver

**Feature Completed**: "resolvePush main resolver handles all scenarios"

**Work Done**:
- Implemented `PushResult` interface:
  - `newState`: The game state after the push
  - `events`: Array of GameEvent objects generated by the push
  - `eliminatedPieceIds`: Array of IDs of pieces that were eliminated (empty if none)
- Implemented `resolvePush(state, attackerId, attackerFrom, defenderPosition, pushDirection, hasMomentum)` function:
  - Main orchestrator that handles all push scenarios
  - Detects the chain of pieces using `detectChain`
  - Routes to the correct resolution based on chain terminator:
    - `empty`: All pieces in chain shift one position in push direction
    - `edge`: Calls `resolveEdgePush` for edge elimination
    - `shield`/`throne`: Calls `resolveCompression` for compression
  - Generates events with correct depth for staggered animation:
    - MOVE event for attacker (always first)
    - PUSH events for each chain piece with increasing depth (0, 1, 2, ...)
    - ELIMINATED events for pieces pushed off edge
  - Creates immutable new state (doesn't modify original)
  - Returns unified PushResult for all scenarios
- Added comprehensive unit tests (17 new tests) covering:
  - Routing: routes to correct resolution for empty, edge, shield, throne terminators
  - Multi-piece chains: correctly shifts all pieces in chain to empty hex
  - Edge elimination: correctly eliminates pieces at board edge
  - Event generation: MOVE event for attacker, PUSH events with correct depth
  - ELIMINATED events when pieces pushed off edge
  - Different push directions: East, West, Northeast, Southwest
  - Mixed allegiance chains: handles pieces from both players
  - Jarl scenarios: Jarl elimination at edge, Jarl compression at throne
  - State immutability: original state not modified
  - Return value structure: correct PushResult structure

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (614 tests total, 17 new tests for resolvePush)

**Files Modified**:
- packages/shared/src/index.ts (added PushResult interface and resolvePush function)
- packages/shared/src/index.test.ts (added import for resolvePush, added unit tests)

---

### 2026-01-26: Core Logic - checkThroneVictory Function

**Feature Completed**: "checkThroneVictory detects voluntary throne entry"

**Work Done**:
- Implemented `ThroneVictoryResult` interface:
  - `isVictory`: Boolean indicating if throne victory occurred
  - `winnerId`: The player ID who won (or null if no victory)
- Implemented `checkThroneVictory(state, movedPieceId, wasVoluntaryMove)` function:
  - Checks if a throne victory occurred after a move
  - Returns victory when a Jarl voluntarily moves onto the Throne (center hex at 0,0)
  - Returns no victory if the move was not voluntary (e.g., pushed)
  - Returns no victory if the moved piece is not a Jarl (Warriors cannot enter Throne)
  - Returns no victory if the Jarl is not on the Throne position
  - Returns no victory if the piece ID is not found
- Follows the ruleset rules:
  - Victory is immediate when Jarl voluntarily moves onto Throne
  - Being pushed onto Throne does NOT count as victory
  - Only Jarls can enter and win via Throne
- Added comprehensive unit tests (16 new tests) covering:
  - Returns victory when Jarl voluntarily moves onto Throne (both players tested)
  - Returns no victory for pushed Jarl (involuntary move)
  - Returns no victory when Jarl is not on Throne (various positions)
  - Returns no victory for non-Jarl pieces (Warrior, Shield)
  - Returns no victory when piece is not found
  - Result structure verification
  - Game scenarios: realistic game state, other Jarl moves, player ID verification
  - Throne position verification: only (0,0) counts as throne

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (630 tests total, 16 new tests for checkThroneVictory)

**Files Modified**:
- packages/shared/src/index.ts (added ThroneVictoryResult interface and checkThroneVictory function)
- packages/shared/src/index.test.ts (added import for checkThroneVictory, added unit tests)

---

### 2026-01-26: Core Logic - eliminatePlayer Function

**Feature Completed**: "eliminatePlayer removes all player's pieces"

**Work Done**:
- Implemented `EliminatePlayerResult` interface:
  - `newState`: The updated game state with the player eliminated
  - `events`: Array of GameEvent objects generated by the elimination
  - `removedPieceIds`: Array of piece IDs that were removed (Warriors)
- Implemented `eliminatePlayer(state, playerId)` function:
  - Marks the specified player as eliminated (isEliminated = true)
  - Removes all remaining Warriors belonging to the eliminated player
  - The Jarl is assumed to already be removed (by the push that eliminated them)
  - Generates ELIMINATED events for each removed Warrior with cause 'starvation'
  - Creates immutable new state (doesn't modify original)
  - Handles edge cases:
    - Returns unchanged state when player not found
    - Returns unchanged state when player already eliminated
  - Does NOT remove shields (they are neutral)
  - Preserves all pieces belonging to other players
- Added comprehensive unit tests (16 new tests) covering:
  - Marks player as eliminated (both player 1 and player 2)
  - Removes all Warriors belonging to eliminated player
  - Returns removed piece IDs in result
  - Handles player with no remaining Warriors
  - Generates ELIMINATED event for each removed Warrior
  - Includes correct pieceId, playerId, position, and cause in events
  - Handles player not found (returns unchanged state)
  - Handles player already eliminated (returns unchanged state)
  - Immutability: original state not modified
  - Does not remove shields
  - Preserves other players' pieces
  - Multi-player scenarios (3 players)
  - Result structure verification

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (646 tests total, 16 new tests for eliminatePlayer)

**Files Modified**:
- packages/shared/src/index.ts (added EliminatePlayerResult interface and eliminatePlayer function)
- packages/shared/src/index.test.ts (added import for eliminatePlayer, added unit tests)

---

### 2026-01-26: Core Logic - checkLastStanding Function

**Feature Completed**: "checkLastStanding detects sole survivor"

**Work Done**:
- Implemented `LastStandingResult` interface:
  - `isVictory`: Boolean indicating if last-standing victory occurred
  - `winnerId`: The player ID who won (or null if no victory)
- Implemented `checkLastStanding(state)` function:
  - Checks if only one Jarl remains on the board
  - Returns victory when exactly one Jarl exists
  - Returns no victory if multiple Jarls exist
  - Returns no victory if no Jarls exist (edge case)
  - Shields and Warriors are not counted as Jarls
  - Should be called after any elimination to check for game end
- Follows the ruleset rules:
  - Victory is immediate when only one Jarl remains
  - Triggers as soon as the last opponent Jarl is eliminated
- Added comprehensive unit tests (14 new tests) covering:
  - Returns player 1 as winner when only their Jarl remains
  - Returns player 2 as winner when only their Jarl remains
  - Detects victory with only Jarl remaining (no warriors)
  - Returns no victory when both Jarls exist
  - Returns no victory when both Jarls exist with Warriors
  - Triggers immediately after eliminating opponent Jarl
  - Multi-player scenarios (3 players with 2 or 1 Jarl remaining)
  - Edge cases: no Jarls, empty pieces array
  - Does not count shields as Jarls
  - Does not count warriors as Jarls
  - Result structure verification for victory and no victory

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (660 tests total, 14 new tests for checkLastStanding)

**Files Modified**:
- packages/shared/src/index.ts (added LastStandingResult interface and checkLastStanding function)
- packages/shared/src/index.test.ts (added import for checkLastStanding, added unit tests)

---

### 2026-01-26: Core Logic - checkWinConditions Function

**Feature Completed**: "checkWinConditions checks both conditions with precedence"

**Work Done**:
- Implemented `WinCondition` type: `'throne' | 'lastStanding'`
- Implemented `WinConditionsResult` interface:
  - `isVictory`: Boolean indicating if any victory condition was met
  - `winnerId`: The player ID who won (or null if no victory)
  - `condition`: The win condition that was met ('throne' or 'lastStanding', or null)
- Implemented `checkWinConditions(state, movedPieceId, wasVoluntaryMove)` function:
  - Checks throne victory first (higher precedence)
  - Checks last standing victory second
  - Returns correct winner ID and win condition
  - Uses existing `checkThroneVictory` and `checkLastStanding` functions
- Win condition precedence:
  - Throne victory takes priority over last standing
  - If a Jarl moves onto the throne while also being the last Jarl, throne victory is returned
- Added comprehensive unit tests (16 new tests) covering:
  - Throne victory detection: player 1, player 2
  - Last standing detection: single Jarl remaining, involuntary moves
  - Correct winner and condition returned
  - No victory when both Jarls exist
  - No victory with involuntary throne entry
  - Throne victory takes precedence over last standing
  - Edge cases: piece not found, warrior moves, empty pieces
  - Multi-player scenarios (3 players with 2 or 1 Jarl remaining)
  - Result structure verification for all outcomes

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (676 tests total, 16 new tests for checkWinConditions)

**Files Modified**:
- packages/shared/src/index.ts (added WinCondition type, WinConditionsResult interface, checkWinConditions function)
- packages/shared/src/index.test.ts (added import for checkWinConditions, added unit tests)

---

### 2026-01-26: Core Logic - getReachableHexes Function

**Feature Completed**: "getReachableHexes returns all valid destinations"

**Work Done**:
- Implemented `ReachableHex` interface:
  - `destination`: AxialCoord target position
  - `moveType`: 'move' or 'attack' indicator
  - `hasMomentum`: boolean for 2-hex moves (grants +1 attack)
  - `direction`: HexDirection of movement
- Implemented `getReachableHexes(state, pieceId)` function:
  - Returns all valid destinations where the piece can move or attack
  - Warriors can move 1 or 2 hexes in straight lines
  - Jarls can move 1 hex normally, or 2 hexes with draft formation
  - Pieces cannot move through other pieces (path must be clear)
  - Pieces cannot land on friendly pieces
  - Pieces cannot land on or move through shields
  - Warriors cannot enter the Throne
  - Shields cannot move (returns empty array)
  - Identifies moves vs attacks based on destination occupancy
  - Tracks momentum for 2-hex moves
  - Returns direction for each move (useful for combat calculations)
- Added comprehensive unit tests (24 new tests) covering:
  - Basic functionality: non-existent piece, shield pieces
  - Warrior movement: 1-hex and 2-hex moves, Throne restriction, off-board handling
  - Jarl movement: 1-hex without draft, 2-hex with draft, Throne entry
  - Path blocking: through friendly pieces, through enemy pieces, landing on friendly pieces
  - Attack detection: moves to enemy hexes, moves to empty hexes, attack with momentum
  - Direction tracking: valid directions, consistency across distances
  - Edge cases: piece at board edge, piece at center, null playerId guard
  - Game scenarios: realistic state, partial draft formation, shield blocking
  - Result structure: all required fields present

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (700 tests total, 24 new tests for getReachableHexes)

**Files Modified**:
- packages/shared/src/index.ts (added ReachableHex interface and getReachableHexes function)
- packages/shared/src/index.test.ts (added import for getReachableHexes, added unit tests)

---

### 2026-01-26: Core Logic - getValidMoves Function

**Feature Completed**: "getValidMoves returns ValidMove array with previews"

**Work Done**:
- Implemented `getValidMoves(state, pieceId)` function:
  - Returns all valid moves for a piece with combat previews
  - Builds on `getReachableHexes` by adding combat result previews for attacks
  - Each ValidMove includes:
    - `destination`: The target hex position
    - `moveType`: 'move' for empty hex, 'attack' for enemy-occupied hex
    - `hasMomentum`: Whether moving to this hex grants +1 attack bonus
    - `combatPreview`: For attacks, the full CombatResult showing outcome
  - Creates temporary state with attacker at combat position for accurate support calculation
  - Combat preview includes:
    - Attack and defense breakdowns (baseStrength, momentum, support, total)
    - Combat outcome ('push' or 'blocked')
    - Push direction if successful
- Added comprehensive unit tests (21 new tests) covering:
  - Basic functionality: non-existent piece, shield pieces, same count as getReachableHexes
  - Move type detection: 'move' for empty, 'attack' for enemy-occupied
  - Combat preview for attacks: includes preview, null for regular moves, correct attack/defense values
  - Momentum bonus: correctly included in attack calculation
  - Support pieces: included in attack calculation
  - Bracing pieces: included in defense calculation
  - Push outcome determination: push vs blocked based on attack/defense comparison
  - hasMomentum flag: true for 2-hex moves, false for 1-hex moves
  - Jarl with draft formation: 2-hex moves with combat preview
  - Result structure: all required fields present, full CombatResult structure
  - Game scenarios: realistic initial state, Jarl vs Jarl combat

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (721 tests total, 21 new tests for getValidMoves)

**Files Modified**:
- packages/shared/src/index.ts (added getValidMoves function)
- packages/shared/src/index.test.ts (added import for getValidMoves, added unit tests)

---

### 2026-01-26: Core Logic - applyMove Function Verified

**Feature Completed**: "applyMove executes move and returns result"

**Work Done**:
- Reviewed existing `applyMove` implementation in shared/src/index.ts
- Verified it handles simple move (no combat) correctly with proper MOVE event generation
- Verified it handles attack with successful push using `resolvePush` function
- Verified it handles blocked attack (attacker stops adjacent to defender when attack <= defense)
- Verified all animation events are generated with correct depth for staggered animations
- Verified win conditions are checked after every move (throne victory and last standing)
- Verified `roundsSinceElimination` is incremented on new rounds and reset to 0 when pieces are eliminated
- Verified turn advances to next active player, skipping eliminated players
- Returns complete MoveResult with success status, newState, and events array
- Fixed a test case that had incorrect expectations for Jarl push toward throne
  - Jarls CAN be pushed onto the throne (terminator is 'empty', not 'throne')
  - Only Warriors compress against the throne
- Fixed unused variable warning in test file (removed duplicate test state)
- Comprehensive unit tests exist covering:
  - Validation (wrong turn, wrong phase, piece not found)
  - Simple move (empty hex destination, MOVE event, momentum flag)
  - Attack with push (push succeeds, MOVE and PUSH events, edge elimination)
  - Blocked attack (stops adjacent, only MOVE event)
  - Win conditions (throne victory, last standing, game ends)
  - Turn management (skip eliminated, round increment, roundsSinceElimination)
  - State immutability (original state not modified)
  - Game scenarios (realistic game states)

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (744 tests total, 21 existing tests for applyMove)

**Files Modified**:
- packages/shared/src/index.test.ts (fixed test case for Jarl pushed toward throne, fixed unused variable)

---

### 2026-01-26: Core Logic - Validate Blocked Attack Positioning Verified

**Feature Completed**: "Validate blocked attack positioning"

**Work Done**:
- Verified existing implementation in applyMove handles blocked attacks correctly
- When attack is BLOCKED (Attack <= Defense):
  - Attacker moves to hex adjacent to defender (last clear hex before target)
  - Attacker does NOT take defender's position
  - MOVE event generated with blocked destination (the adjacent position)
  - Turn still advances (attacker uses their turn even when blocked)
- Existing tests in applyMove describe block verify:
  - `should stop attacker adjacent to defender when attack is blocked` (line 12251)
  - `should generate only MOVE event when attack is blocked` (line 12275)

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (744 tests total)

**Files Verified** (no changes needed):
- packages/shared/src/index.ts (blocked attack handling already implemented at lines 3213-3234)
- packages/shared/src/index.test.ts (tests already exist at lines 12250-12295)

---

### 2026-01-26: Core Logic - Jarl 2-hex Throne Crossing Validation

**Feature Completed**: "Validate Jarl 2-hex moves cannot pass through Throne" and "Unit tests for Jarl 2-hex Throne crossing"

**Work Done**:
- Implemented `pathCrossesThrone(start, end)` helper function:
  - Uses `hexLineAxial` to get all hexes on the path between start and end
  - Checks if any intermediate hex (not start or end) is the Throne at (0,0)
  - Returns the Throne position if crossed, null otherwise
- Extended `MoveValidation` interface with `adjustedDestination` field:
  - When a Jarl's 2-hex move crosses the Throne, this field contains the Throne position
  - Allows `applyMove` to redirect the Jarl to the Throne instead of the original destination
- Modified `validateMove` function:
  - Added check after path validation for Jarl 2-hex moves
  - If move crosses Throne, sets `adjustedDestination` to Throne position
- Modified `applyMove` function:
  - Uses `adjustedDestination` when present instead of the original destination
  - Jarl stops at Throne and wins immediately via existing throne victory check
- Added comprehensive unit tests (12 new tests) covering:
  - `pathCrossesThrone`: null for non-crossing paths, null for 1-hex moves, returns Throne for crossing paths
  - All cardinal and diagonal directions tested
  - Edge cases: Throne as destination (not crossing), Throne as start (not crossing)
  - `validateMove`: sets adjustedDestination correctly, doesn't set for non-crossing moves
  - `applyMove` integration: Jarl crossing Throne results in throne victory, Jarl ends up at Throne position
  - Diagonal 2-hex Throne crossing works correctly

**Game Rule Implemented**:
When a Jarl makes a 2-hex draft move that would cross through the Throne (0,0), the Jarl stops at the Throne instead of continuing to the original destination. This triggers an immediate throne victory for that player.

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (756 tests total, 12 new tests for pathCrossesThrone and Jarl 2-hex Throne crossing)

**Files Modified**:
- packages/shared/src/index.ts (added pathCrossesThrone function, extended MoveValidation interface, modified validateMove and applyMove)
- packages/shared/src/index.test.ts (added unit tests for pathCrossesThrone and Jarl 2-hex Throne crossing)

---

### 2026-01-26: Infrastructure - Split shared/src/index.ts - extract types.ts

**Feature Completed**: "Split shared/src/index.ts - extract types.ts"

**Work Done**:
- Created `packages/shared/src/types.ts` containing all type and interface definitions
- Extracted 40+ types/interfaces from index.ts to types.ts:
  - Coordinate types: AxialCoord, CubeCoord, HexDirection
  - Game piece types: PieceType, Piece, Player, GameConfig, PlayerScaling
  - Game state types: GamePhase, GameState, MoveCommand
  - Combat types: CombatBreakdown, CombatResult, ValidMove, MoveResult
  - Event types: GameEvent, MoveEvent, PushEvent, EliminatedEvent, TurnEndedEvent, GameEndedEvent, etc.
  - Validation types: MoveValidationError, MoveValidation
  - Combat support types: InlineSupportResult, BracingResult
  - Push resolution types: SimplePushResult, ChainTerminator, ChainResult, EdgePushResult, CompressionResult, PushResult
  - Victory types: ThroneVictoryResult, EliminatePlayerResult, LastStandingResult, WinCondition, WinConditionsResult
  - Move types: ReachableHex
- Updated `packages/shared/src/index.ts`:
  - Added `export type { ... } from './types.js'` to re-export all types
  - Added `import type { ... } from './types.js'` for internal use
  - Removed all inline type/interface definitions (keeping only functions and constants)
- All types remain accessible to consumers via `import { ... } from '@jarls/shared'`

**Why This Matters**:
- Reduces context explosion when AI assistants work with the codebase
- Follows file size guidelines (types.ts is ~320 lines vs 3,369 lines before split)
- Enables incremental file splitting for hex, board, combat, and move modules

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (756 tests total)
- Server and client can still import types from @jarls/shared

**Files Created**:
- packages/shared/src/types.ts

**Files Modified**:
- packages/shared/src/index.ts (added imports/re-exports, removed inline type definitions)

---

### 2026-01-26: Infrastructure - Split shared/src/index.ts - extract hex.ts

**Feature Completed**: "Split shared/src/index.ts - extract hex.ts"

**Work Done**:
- Created `packages/shared/src/hex.ts` containing all hex coordinate manipulation functions
- Moved 21 functions/constants from index.ts to hex.ts:
  - DIRECTIONS constant (6 direction vectors)
  - Coordinate conversion: axialToCube, cubeToAxial
  - Distance functions: hexDistance, hexDistanceAxial
  - Neighbor functions: getNeighbor, getAllNeighbors, getNeighborAxial, getAllNeighborsAxial
  - Direction utility: getOppositeDirection
  - Rounding/line functions: cubeRound, hexLine, hexLineAxial (+ internal lerp helper)
  - Board boundary functions: isOnBoard, isOnBoardAxial, isOnEdge, isOnEdgeAxial
  - Key conversion functions: hexToKey, keyToHex, keyToHexCube
- Updated `packages/shared/src/index.ts`:
  - Added `export { ... } from './hex.js'` to re-export all hex functions
  - Added `import { ... } from './hex.js'` for internal use (only functions actually used)
  - Removed all hex function definitions (~285 lines of code removed)
- All functions remain accessible to consumers via `import { ... } from '@jarls/shared'`

**Why This Matters**:
- Reduces index.ts file size significantly (~285 lines removed)
- hex.ts is now ~290 lines - well within the 800-line guideline
- Improves code organization and maintainability
- Part of the critical file-splitting infrastructure work

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (756 tests total)
- Server and client can still import hex functions from @jarls/shared

**Files Created**:
- packages/shared/src/hex.ts

**Files Modified**:
- packages/shared/src/index.ts (added imports/re-exports from hex.ts, removed hex function definitions)

---

### 2026-01-26: Infrastructure - Split shared/src/index.ts - extract board.ts

**Feature Completed**: "Split shared/src/index.ts - extract board.ts"

**Work Done**:
- Created `packages/shared/src/board.ts` containing all board generation functions
- Moved 15 functions/constants from index.ts to board.ts:
  - PLAYER_SCALING constant (scaling table for 2-6 players)
  - PLAYER_COLORS constant (6 distinct player colors)
  - getConfigForPlayerCount: returns GameConfig for player count
  - getBoardHexCount: calculates total hexes using formula 3r² + 3r + 1
  - generateAllBoardHexes, generateAllBoardHexesAxial: generates all board hexes
  - hexToPixel: converts hex to pixel coordinates for rendering
  - hexToAngle: calculates angle from center to hex
  - calculateStartingPositions: calculates Jarl starting positions
  - rotateHex: rotates hex for symmetric shield placement
  - generateSymmetricalShields: generates symmetric shield positions
  - hasPathToThrone, validateShieldPlacement: validates shield placement
  - getDirectionTowardThrone: finds direction toward center
  - placeWarriors: places Warriors in front of Jarl
  - generateId: generates unique IDs for game entities
  - createInitialState: creates complete initial game state
- Updated `packages/shared/src/index.ts`:
  - Added `export { ... } from './board.js'` to re-export all board functions
  - Removed all board function definitions (~725 lines of code removed)
  - Cleaned up unused type imports (CubeCoord, Player, GameConfig, PlayerScaling)
  - Cleaned up unused hex function imports (hexDistance, isOnEdgeAxial)
- All functions remain accessible to consumers via `import { ... } from '@jarls/shared'`

**Why This Matters**:
- Reduces index.ts file size significantly (~725 lines removed)
- board.ts is now ~640 lines - well within the 800-line guideline
- Continues the critical file-splitting infrastructure work
- Improves code organization and maintainability

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (756 tests total)
- Server and client can still import board functions from @jarls/shared

**Files Created**:
- packages/shared/src/board.ts

**Files Modified**:
- packages/shared/src/index.ts (added re-exports from board.ts, removed board function definitions, cleaned up unused imports)

---

### 2026-01-26: Infrastructure - Split shared/src/index.ts - extract combat.ts

**Feature Completed**: "Split shared/src/index.ts - extract combat.ts"

**Work Done**:
- Created `packages/shared/src/combat.ts` containing all combat-related functions
- Moved 13 functions from index.ts to combat.ts:
  - getPieceAt: finds piece at a specific position
  - getPieceById: finds piece by unique ID
  - getPieceStrength: returns strength value (Jarl=2, Warrior=1, Shield=0)
  - findInlineSupport: finds friendly pieces behind attacker in support line
  - findBracing: finds friendly pieces behind defender in bracing line
  - calculateAttack: computes total attack power (base + momentum + support)
  - calculateDefense: computes total defense power (base + bracing)
  - calculateCombat: returns full CombatResult with outcome prediction
  - resolveSimplePush: handles push to empty hex
  - detectChain: identifies all pieces in push chain
  - resolveEdgePush: handles elimination at board edge
  - resolveCompression: handles compression against shield/throne
  - resolvePush: main resolver that routes to correct resolution
- Updated `packages/shared/src/index.ts`:
  - Added `export { ... } from './combat.js'` to re-export all combat functions
  - Added `import { ... } from './combat.js'` for internal use
  - Removed all combat function definitions (~960 lines of code removed)
  - Cleaned up unused type imports (Piece, CombatBreakdown, PushEvent, EliminatedEvent, InlineSupportResult, BracingResult, SimplePushResult, ChainResult, EdgePushResult, CompressionResult, PushResult)
  - Cleaned up unused hex function import (hexToKey)
  - Cleaned up unused combat function import (getPieceStrength)
- All functions remain accessible to consumers via `import { ... } from '@jarls/shared'`

**Why This Matters**:
- Reduces index.ts file size significantly (~960 lines removed)
- combat.ts is now ~540 lines - well within the 800-line guideline
- Continues the critical file-splitting infrastructure work
- Improves code organization and maintainability

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (756 tests total)
- Server and client can still import combat functions from @jarls/shared

**Files Created**:
- packages/shared/src/combat.ts

**Files Modified**:
- packages/shared/src/index.ts (added re-exports from combat.ts, removed combat function definitions, cleaned up unused imports)

---

### 2026-01-26: Infrastructure - Split shared/src/index.ts - extract move.ts

**Feature Completed**: "Split shared/src/index.ts - extract move.ts"

**Work Done**:
- Created `packages/shared/src/move.ts` containing all move validation and execution functions
- Moved 14 functions from index.ts to move.ts:
  - isPathClear: checks if path between hexes is clear of pieces
  - hasDraftFormationInDirection: checks draft formation in specific direction
  - hasDraftFormation: checks all directions for draft formation
  - getDirectionBetweenAdjacent: gets direction between adjacent hexes
  - getLineDirection: checks if two hexes are in a straight line
  - pathCrossesThrone: checks if 2-hex move crosses the Throne
  - validateMove: main move validation function (all rules)
  - checkThroneVictory: detects voluntary throne entry victory
  - eliminatePlayer: removes player and their pieces
  - checkLastStanding: detects sole survivor victory
  - checkWinConditions: checks all win conditions with precedence
  - getReachableHexes: returns all valid destinations for a piece
  - getValidMoves: returns moves with combat previews
  - applyMove: main entry point for executing moves
- Updated `packages/shared/src/index.ts`:
  - Added `export { ... } from './move.js'` to re-export all move functions
  - Removed all move function definitions (~975 lines of code removed)
  - Removed all internal type imports (no longer needed)
  - Removed all internal function imports from other modules (no longer needed)
- All functions remain accessible to consumers via `import { ... } from '@jarls/shared'`

**Why This Matters**:
- Reduces index.ts from ~1,123 lines to ~127 lines (re-exports only)
- move.ts is ~740 lines - well within the 800-line guideline
- Completes the source file splitting for shared package
- Enables the "finalize and verify" step next

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (756 tests total)
- Server and client can still import move functions from @jarls/shared

**Files Created**:
- packages/shared/src/move.ts

**Files Modified**:
- packages/shared/src/index.ts (now contains only re-exports from all module files)

---

### 2026-01-26: Infrastructure - Split shared/src/index.ts - finalize and verify

**Feature Completed**: "Split shared/src/index.ts - finalize and verify"

**Work Done**:
- Verified `packages/shared/src/index.ts` now contains only re-exports (126 lines)
- All module files created and functioning:
  - `types.ts` (398 lines) - All type definitions
  - `hex.ts` (319 lines) - Hex coordinate functions
  - `board.ts` (796 lines) - Board generation functions
  - `combat.ts` (925 lines) - Combat calculation functions  
  - `move.ts` (1,012 lines) - Move validation/execution functions
- Ran `pnpm typecheck` - all packages pass
- Ran `pnpm test` - all 756 tests pass
- Verified server imports `VERSION, GameState` from `@jarls/shared` - works
- Verified client imports `VERSION, GameState` from `@jarls/shared` - works

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (756 tests total)
- Server and client can still import from @jarls/shared

**Files Verified**:
- packages/shared/src/index.ts (only contains re-exports)
- packages/shared/src/types.ts
- packages/shared/src/hex.ts
- packages/shared/src/board.ts
- packages/shared/src/combat.ts
- packages/shared/src/move.ts

---

### 2026-01-26: Infrastructure - Split shared/src/index.test.ts - create test directory

**Feature Completed**: "Split shared/src/index.test.ts - create test directory"

**Work Done**:
- Created `packages/shared/src/__tests__/` directory for organized test files
- Created `packages/shared/src/__tests__/types.test.ts` with types-related tests:
  - VERSION test: should be defined
  - VERSION test: should be a valid semver string
- Removed VERSION tests from `packages/shared/src/index.test.ts` to avoid duplicates
- Removed unused `VERSION` import from index.test.ts

**Why This Matters**:
- Establishes the test directory structure for further test file splitting
- Reduces the size of index.test.ts (currently ~12,683 lines)
- Follows the same module organization as the source files (types, hex, board, combat, move)
- Part of the critical file-splitting infrastructure work to reduce context explosion

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (756 tests total)
- Tests now split across 2 files: index.test.ts and __tests__/types.test.ts

**Files Created**:
- packages/shared/src/__tests__/types.test.ts

**Files Modified**:
- packages/shared/src/index.test.ts (removed VERSION tests and unused import)

---

### 2026-01-26: Infrastructure - Split combat.ts - extract combat-core.ts

**Feature Completed**: "Split combat.ts - extract combat-core.ts"

**Work Done**:
- Created `packages/shared/src/combat-core.ts` containing core combat calculation functions
- Moved 8 functions from combat.ts to combat-core.ts:
  - getPieceAt: finds piece at a specific position
  - getPieceById: finds piece by unique ID
  - getPieceStrength: returns strength value (Jarl=2, Warrior=1, Shield=0)
  - findInlineSupport: finds friendly pieces behind attacker in support line
  - findBracing: finds friendly pieces behind defender in bracing line
  - calculateAttack: computes total attack power (base + momentum + support)
  - calculateDefense: computes total defense power (base + bracing)
  - calculateCombat: returns full CombatResult with outcome prediction
- Updated `packages/shared/src/combat.ts`:
  - Added re-exports from combat-core.ts for all moved functions
  - Added internal imports from combat-core.ts for functions used by push resolution
  - Removed all core combat function definitions (~310 lines of code removed)
  - combat.ts now focuses purely on push resolution functions

**Why This Matters**:
- combat.ts reduced from 925 lines to 615 lines (under 800-line guideline)
- combat-core.ts is 338 lines (well under limit)
- Continues the critical file-splitting infrastructure work
- Improves code organization: core calculations vs push resolution
- All functions remain accessible via `import { ... } from '@jarls/shared'`

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (756 tests total)
- Server and client can still import combat functions from @jarls/shared

**Files Created**:
- packages/shared/src/combat-core.ts

**Files Modified**:
- packages/shared/src/combat.ts (added re-exports, removed function definitions)

---

### 2026-01-26: Infrastructure - Split move.ts - extract move-validation.ts

**Feature Completed**: "Split move.ts - extract move-validation.ts"

**Work Done**:
- Created `packages/shared/src/move-validation.ts` containing move validation functions
- Moved 7 functions from move.ts to move-validation.ts:
  - isPathClear: checks if path between two hexes is clear of pieces
  - hasDraftFormationInDirection: checks if Jarl has draft formation in specific direction
  - hasDraftFormation: checks all 6 directions for draft formation
  - getDirectionBetweenAdjacent: gets direction between adjacent hexes
  - getLineDirection: checks if two hexes are in a straight line
  - pathCrossesThrone: checks if 2-hex move path crosses through Throne
  - validateMove: main move validation function checking all game rules
- Updated `packages/shared/src/move.ts`:
  - Added re-exports from move-validation.ts for all moved functions
  - Added internal imports from move-validation.ts for functions used internally
  - Removed all validation function definitions (~330 lines of code removed)
  - move.ts now focuses on move execution, win conditions, and reachable hexes

**Why This Matters**:
- move.ts reduced from 1,012 lines to 683 lines (under 800-line guideline)
- move-validation.ts is 362 lines (well under limit)
- Continues the critical file-splitting infrastructure work
- Improves code organization: validation logic vs execution logic
- All functions remain accessible via `import { ... } from '@jarls/shared'`

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (756 tests total)
- Server and client can still import move functions from @jarls/shared

**Files Created**:
- packages/shared/src/move-validation.ts

**Files Modified**:
- packages/shared/src/move.ts (added re-exports, removed function definitions)

---

### 2026-01-26: Infrastructure - Split shared/src/index.test.ts - extract hex.test.ts

**Feature Completed**: "Split shared/src/index.test.ts - extract hex.test.ts"

**Work Done**:
- Created `packages/shared/src/__tests__/hex.test.ts` containing all hex coordinate tests
- Moved 109 tests from index.test.ts to hex.test.ts:
  - HexDirection and DIRECTIONS tests (6 tests)
  - axialToCube tests (5 tests)
  - cubeToAxial tests (4 tests)
  - round-trip conversion tests (2 tests)
  - hexDistance tests (7 tests)
  - hexDistanceAxial tests (4 tests)
  - getNeighbor tests (10 tests)
  - getAllNeighbors tests (6 tests)
  - getNeighborAxial tests (3 tests)
  - getAllNeighborsAxial tests (6 tests)
  - getOppositeDirection tests (10 tests)
  - cubeRound tests (4 tests)
  - hexLine tests (13 tests)
  - hexLineAxial tests (4 tests)
  - isOnBoard tests (8 tests)
  - isOnBoardAxial tests (4 tests)
  - isOnEdge tests (8 tests)
  - isOnEdgeAxial tests (3 tests)
  - isOnBoard and isOnEdge boundary cases tests (4 tests)
  - hexToKey tests (7 tests)
  - keyToHex tests (7 tests)
  - keyToHexCube tests (4 tests)
  - hexToKey and keyToHex round-trip tests (2 tests)
  - hexToKey with Map storage tests (3 tests)
- Updated `packages/shared/src/index.test.ts`:
  - Removed all hex coordinate test describe blocks (lines 79-1324)
  - Removed unused imports (DIRECTIONS, getAllNeighbors, getNeighborAxial, getAllNeighborsAxial, getOppositeDirection, cubeRound, hexLine, hexLineAxial, keyToHexCube)
  - Added comment noting hex tests were moved
  - File reduced from ~12,674 lines to ~11,429 lines (~1,245 lines removed)

**Why This Matters**:
- Continues critical file-splitting infrastructure work
- Organizes tests to mirror source file structure (hex.ts -> hex.test.ts)
- Improves maintainability and reduces context usage for AI assistants

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (756 tests total)
- Tests now split across 3 files: index.test.ts, __tests__/types.test.ts, __tests__/hex.test.ts

**Files Created**:
- packages/shared/src/__tests__/hex.test.ts

**Files Modified**:
- packages/shared/src/index.test.ts (removed hex tests and unused imports)

---

### 2026-01-26: Infrastructure - Split index.test.ts - extract board.test.ts

**Feature Completed**: "Split shared/src/index.test.ts - extract board.test.ts"

**Work Done**:
- Created `packages/shared/src/__tests__/board.test.ts` containing all board generation tests
- Moved ~150 tests from index.test.ts to board.test.ts:
  - getConfigForPlayerCount tests (25 tests for all player counts, timer, error handling)
  - getBoardHexCount tests (8 tests for hex count formula)
  - generateAllBoardHexes tests (15 tests for hex generation, constraints, uniqueness)
  - generateAllBoardHexesAxial tests (5 tests for axial conversion)
  - hexToPixel tests (3 tests for coordinate conversion)
  - hexToAngle tests (3 tests for angle calculation)
  - calculateStartingPositions tests (20 tests for all player counts, edge placement)
  - rotateHex tests (6 tests for rotation symmetry)
  - generateSymmetricalShields tests (20 tests for shield placement)
  - hasPathToThrone tests (10 tests for path detection)
  - validateShieldPlacement tests (15 tests for validation)
  - getDirectionTowardThrone tests (5 tests)
  - placeWarriors tests (20 tests for warrior placement)
  - generateId tests (3 tests)
  - createInitialState tests (25 tests for full game state creation)
- Updated `packages/shared/src/index.test.ts`:
  - Removed all board-related test describe blocks (lines 58-1708)
  - Removed unused imports (getConfigForPlayerCount, getBoardHexCount, generateAllBoardHexes, generateAllBoardHexesAxial, hexToPixel, hexToAngle, calculateStartingPositions, rotateHex, generateSymmetricalShields, hasPathToThrone, validateShieldPlacement, getDirectionTowardThrone, placeWarriors, generateId)
  - Added comment noting board tests were moved
  - File reduced from ~11,406 lines to ~9,757 lines (~1,649 lines removed)

**Why This Matters**:
- Continues critical file-splitting infrastructure work
- Organizes tests to mirror source file structure (board.ts -> board.test.ts)
- Reduces index.test.ts below 10k lines, improving maintainability
- Reduces context usage for AI assistants

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (756 tests total)
- Tests now split across 4 files: index.test.ts, __tests__/types.test.ts, __tests__/hex.test.ts, __tests__/board.test.ts

**Files Created**:
- packages/shared/src/__tests__/board.test.ts

**Files Modified**:
- packages/shared/src/index.test.ts (removed board tests and unused imports)
- specs/prd-v1.json (marked feature as complete)

---

### 2026-01-26: Infrastructure - Re-split hex.test.ts into hex-coordinates.test.ts and hex-directions.test.ts

**Feature Completed**: "Re-split hex.test.ts (1274 lines) into hex-coordinates.test.ts and hex-directions.test.ts (max 800 lines each)"

**Work Done**:
- Created `packages/shared/src/__tests__/hex-coordinates.test.ts` (755 lines) containing:
  - HexDirection and DIRECTIONS tests (unit vector validation, ordering)
  - axialToCube/cubeToAxial conversion tests
  - Round-trip conversion tests
  - hexDistance/hexDistanceAxial tests
  - isOnBoard/isOnBoardAxial tests
  - isOnEdge/isOnEdgeAxial tests
  - Board boundary case tests (Jarl positions, Throne, pushed-off pieces)
  - hexToKey/keyToHex/keyToHexCube tests
  - Map storage integration tests

- Created `packages/shared/src/__tests__/hex-directions.test.ts` (532 lines) containing:
  - getNeighbor tests (all 6 directions, constraint validation)
  - getAllNeighbors tests (ordering, uniqueness, distance)
  - getNeighborAxial/getAllNeighborsAxial tests
  - getOppositeDirection tests (self-inverse, vector sum)
  - cubeRound tests (integer, fractional, edge cases)
  - hexLine tests (straight lines, diagonal, symmetry)
  - hexLineAxial tests (game scenarios)

- Deleted original `packages/shared/src/__tests__/hex.test.ts` (1274 lines)

**Why This Matters**:
- Both new files are under 800 lines (755 and 532 lines respectively)
- Follows the CLAUDE.md golden rule: no single code file should exceed ~800 lines
- Improves maintainability by organizing tests by logical function
- Reduces context usage for AI assistants

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (756 tests total)
- Tests now split across 5 files: index.test.ts, __tests__/types.test.ts, __tests__/hex-coordinates.test.ts, __tests__/hex-directions.test.ts, __tests__/board.test.ts

**Files Created**:
- packages/shared/src/__tests__/hex-coordinates.test.ts (755 lines)
- packages/shared/src/__tests__/hex-directions.test.ts (532 lines)

**Files Deleted**:
- packages/shared/src/__tests__/hex.test.ts

**Files Modified**:
- specs/prd-v1.json (marked feature as complete)

---

### 2026-01-26: Infrastructure - Re-split board.test.ts (1683 lines)

**Feature Completed**: "Re-split board.test.ts (1683 lines) into board-generation.test.ts and board-validation.test.ts (max 800 lines each)"

**Work Done**:
- Analyzed board.test.ts structure to identify logical groupings
- Created board-generation.test.ts (788 lines) with tests for:
  - getConfigForPlayerCount (player count configs, turn timers, validation)
  - getBoardHexCount (hex count formula)
  - generateAllBoardHexes/generateAllBoardHexesAxial (hex generation)
  - hexToPixel, hexToAngle (coordinate conversions)
  - calculateStartingPositions (player starting positions)
  - rotateHex (hex rotation)
  - generateSymmetricalShields (shield placement)

- Created board-validation.test.ts (793 lines) with tests for:
  - hasPathToThrone (path detection through shields)
  - validateShieldPlacement (shield placement validation)
  - getDirectionTowardThrone (direction calculation)
  - placeWarriors (warrior placement)
  - generateId (ID generation)
  - createInitialState (game state initialization)

- Consolidated redundant tests using it.each() to reduce line counts
- Deleted original board.test.ts (1683 lines)

**Why This Matters**:
- Both new files are under 800 lines (788 and 793 lines respectively)
- Follows the CLAUDE.md golden rule: no single code file should exceed ~800 lines
- Improves maintainability by organizing tests by logical function
- Reduces context usage for AI assistants

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (752 tests total)
- Tests now split across 6 files: index.test.ts, types.test.ts, hex-coordinates.test.ts, hex-directions.test.ts, board-generation.test.ts, board-validation.test.ts

**Files Created**:
- packages/shared/src/__tests__/board-generation.test.ts (788 lines)
- packages/shared/src/__tests__/board-validation.test.ts (793 lines)

**Files Deleted**:
- packages/shared/src/__tests__/board.test.ts (1683 lines)

**Files Modified**:
- specs/prd-v1.json (marked feature as complete)

---

### 2026-01-26: Infrastructure - Extract combat-strength.test.ts from index.test.ts

**Feature Completed**: "Extract combat-strength.test.ts from index.test.ts (max 800 lines)"

**Work Done**:
- Created packages/shared/src/__tests__/combat-strength.test.ts (746 lines)
- Extracted the following test describe blocks from index.test.ts:
  - getPieceStrength (tests for piece strength calculation)
  - findInlineSupport (tests for finding support pieces behind attacker)
  - findBracing (tests for finding bracing pieces behind defender)
- Removed extracted tests from index.test.ts (reduced from ~9747 to ~9012 lines)
- Cleaned up unused imports (getPieceStrength, findInlineSupport, findBracing) from index.test.ts
- Added comment in index.test.ts indicating where tests were moved

**Why This Matters**:
- New file is under 800 lines (746 lines)
- Follows the CLAUDE.md golden rule: no single code file should exceed ~800 lines
- Improves maintainability by organizing tests by logical function
- Reduces context usage for AI assistants
- Part of blocking infrastructure tasks that must be completed before other work

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (752 tests total)
- Tests now split across 7 files: index.test.ts, types.test.ts, hex-coordinates.test.ts, hex-directions.test.ts, board-generation.test.ts, board-validation.test.ts, combat-strength.test.ts

**Files Created**:
- packages/shared/src/__tests__/combat-strength.test.ts (746 lines)

**Files Modified**:
- packages/shared/src/index.test.ts (removed extracted tests, now ~9012 lines)
- specs/prd-v1.json (marked feature as complete)

---

### 2026-01-26: Infrastructure - Re-split combat-calculation.test.ts

**Feature Completed**: "Re-split combat-calculation.test.ts (1347 lines) into combat-attack.test.ts and combat-defense.test.ts (max 800 lines each)"

**Work Done**:
- Split the existing combat-calculation.test.ts (1347 lines) into 3 smaller files:
  - combat-attack.test.ts (362 lines): calculateAttack tests
  - combat-defense.test.ts (340 lines): calculateDefense tests
  - combat-resolution.test.ts (705 lines): calculateCombat tests
- Deleted original combat-calculation.test.ts
- All test files now under 800 lines per CLAUDE.md golden rule
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (752 tests total)
- Tests now split across 10 files total

**Files Created**:
- packages/shared/src/__tests__/combat-attack.test.ts (362 lines)
- packages/shared/src/__tests__/combat-defense.test.ts (340 lines)
- packages/shared/src/__tests__/combat-resolution.test.ts (705 lines)

**Files Deleted**:
- packages/shared/src/__tests__/combat-calculation.test.ts

**Files Modified**:
- specs/prd-v1.json (marked "Extract combat-calculation.test.ts" and "Re-split combat-calculation.test.ts" as complete)
