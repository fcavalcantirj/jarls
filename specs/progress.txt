## Progress Log

### 2026-01-25: Infrastructure - Monorepo Initialization

**Feature Completed**: "Monorepo initialized with npm workspaces"

**Work Done**:
- Created root package.json with pnpm workspaces configuration
- Created pnpm-workspace.yaml for workspace configuration
- Created packages/shared, packages/server, packages/client directories
- Set up package.json for each package with appropriate dependencies:
  - @jarls/shared: Core shared types package
  - @jarls/server: Node.js game server with tsx for development
  - @jarls/client: React + Vite frontend
- Created tsconfig.base.json with strict TypeScript settings
- Created tsconfig.json for each package with project references
- Added basic source files demonstrating cross-package imports
- Verified pnpm install works correctly from root
- Verified pnpm typecheck passes
- Verified pnpm test passes

**Files Created**:
- package.json (root)
- pnpm-workspace.yaml
- tsconfig.base.json
- packages/shared/package.json
- packages/shared/tsconfig.json
- packages/shared/src/index.ts
- packages/server/package.json
- packages/server/tsconfig.json
- packages/server/src/index.ts
- packages/client/package.json
- packages/client/tsconfig.json
- packages/client/vite.config.ts
- packages/client/index.html
- packages/client/src/main.tsx
- packages/client/src/App.tsx

---

### 2026-01-25: Infrastructure - TypeScript Configuration Verified

**Feature Completed**: "TypeScript configured for all packages"

**Verification**:
- Root tsconfig.base.json exists with shared compiler options (target ES2022, strict mode, etc.)
- Each package (shared, server, client) has tsconfig.json extending ../../tsconfig.base.json
- TypeScript project references configured: server and client reference ../shared
- Strict mode enabled via `"strict": true` in tsconfig.base.json
- `pnpm typecheck` passes for all packages

**Files Verified**:
- tsconfig.base.json
- packages/shared/tsconfig.json
- packages/server/tsconfig.json
- packages/client/tsconfig.json

---

### 2026-01-25: Infrastructure - Shared Types Importable

**Feature Completed**: "Shared types importable from @jarls/shared"

**Work Done**:
- Added core game types to packages/shared/src/index.ts:
  - AxialCoord, CubeCoord interfaces for hexagonal coordinates
  - PieceType type and Piece interface
  - Player interface
  - GameConfig interface
  - GamePhase type
  - GameState interface (the main shared type)
- Updated server to import GameState: `import { GameState } from '@jarls/shared'`
- Updated client to import GameState: `import { GameState } from '@jarls/shared'`
- Built shared package to generate dist folder with type declarations
- Verified `pnpm typecheck` passes for all packages
- Verified `pnpm test` passes for all packages

**Files Modified**:
- packages/shared/src/index.ts (added all core game types)
- packages/server/src/index.ts (added GameState import and usage)
- packages/client/src/App.tsx (added GameState import and usage)

---

### 2026-01-25: Infrastructure - ESLint Configuration

**Feature Completed**: "ESLint configured with TypeScript rules"

**Work Done**:
- Installed ESLint 9.x with TypeScript ESLint dependencies at workspace root:
  - eslint, @eslint/js, typescript-eslint
  - @typescript-eslint/parser, @typescript-eslint/eslint-plugin
- Created eslint.config.js using ESLint 9 flat config format
- Configured TypeScript-ESLint with recommended rules
- Added project service for type-aware linting
- Configured ignores for dist, node_modules, and generated JS files
- Updated root package.json:
  - Added `"type": "module"` for ESM support
  - Updated lint script to run ESLint on all package source files
- Verified `pnpm lint` runs successfully with no errors
- Verified `pnpm typecheck` still passes
- Verified `pnpm test` still passes

**Files Created**:
- eslint.config.js

**Files Modified**:
- package.json (added type:module, ESLint dependencies, updated lint script)

---

### 2026-01-25: Infrastructure - Prettier Configuration

**Feature Completed**: "Prettier configured for code formatting"

**Work Done**:
- Installed Prettier 3.x and eslint-config-prettier at workspace root
- Created .prettierrc with formatting rules:
  - Semi-colons enabled
  - Single quotes preferred
  - Tab width of 2 spaces
  - Trailing commas in ES5 contexts
  - Print width of 100 characters
  - LF line endings
- Created .prettierignore to exclude node_modules, dist, coverage, etc.
- Updated eslint.config.js to integrate eslint-config-prettier (disables conflicting rules)
- Updated root package.json:
  - Added format:check script for CI verification
- Ran `pnpm format` to format entire codebase
- Verified `pnpm format:check` passes (all files formatted)
- Verified `pnpm typecheck` still passes
- Verified `pnpm lint` still passes
- Verified `pnpm test` still passes

**Files Created**:
- .prettierrc
- .prettierignore

**Files Modified**:
- eslint.config.js (added eslint-config-prettier integration)
- package.json (added prettier, eslint-config-prettier dependencies, format:check script)

---

### 2026-01-25: Infrastructure - Git Hooks Configuration

**Feature Completed**: "Git hooks configured with Husky and lint-staged"

**Work Done**:
- Installed Husky 9.x and lint-staged 16.x at workspace root
- Ran `npx husky init` to initialize Husky:
  - Created .husky directory with pre-commit hook
  - Added `prepare` script to package.json for automatic Husky setup
- Configured pre-commit hook to run `npx lint-staged`
- Added lint-staged configuration to package.json:
  - TypeScript files (*.ts, *.tsx): runs ESLint with --fix, then Prettier
  - Other files (*.js, *.jsx, *.json, *.md, *.yml, *.yaml): runs Prettier
- Tested lint-staged directly with `npx lint-staged` - works correctly
- Verified `pnpm typecheck` still passes
- Verified `pnpm test` still passes

**Files Created**:
- .husky/pre-commit

**Files Modified**:
- package.json (added husky, lint-staged dependencies, prepare script, lint-staged config)

---

### 2026-01-25: Infrastructure - Jest Testing Configuration

**Feature Completed**: "Jest configured for testing"

**Work Done**:
- Installed Jest 30.x, ts-jest, @types/jest, and jest-environment-jsdom at workspace root
- Created jest.config.js using ESM export format with project references:
  - Separate project configurations for shared, server, and client packages
  - ts-jest configured with ESM support for TypeScript
  - jsdom test environment configured for client package (React testing)
  - Module name mappers for ESM compatibility and workspace package resolution
- Updated root package.json test script to run Jest with NODE_OPTIONS for ESM support
- Updated each package's test script to run Jest with --selectProjects for package-specific testing
- Created sample test file (packages/shared/src/index.test.ts) demonstrating test setup
- Test files use *.test.ts naming convention as required

**Verification**:
- `pnpm test` runs Jest successfully, finding and executing test files
- `pnpm typecheck` still passes for all packages
- `pnpm lint` still passes with no errors
- 2 tests passing in shared package

**Files Created**:
- jest.config.js
- packages/shared/src/index.test.ts

**Files Modified**:
- package.json (added jest, ts-jest, @types/jest, jest-environment-jsdom dependencies, updated test script)
- packages/shared/package.json (updated test script)
- packages/server/package.json (updated test script)
- packages/client/package.json (updated test script)

---

### 2026-01-25: Infrastructure - Server Hot-Reload Configuration

**Feature Completed**: "Server hot-reload configured with nodemon"

**Work Done**:
- Installed nodemon 3.x in the server package
- Created packages/server/nodemon.json with configuration:
  - Watches src directory for TypeScript file changes
  - Ignores test files (*.test.ts)
  - Uses tsx to execute TypeScript directly
- Updated packages/server/package.json:
  - Changed dev script from `tsx watch` to `nodemon`
- Added `"type": "module"` to packages/shared/package.json to fix ESM resolution for runtime imports
- Tested hot-reload: server starts correctly and logs output from @jarls/shared

**Verification**:
- `pnpm dev` (in packages/server) starts nodemon which executes tsx
- Server outputs "Jarls Server v0.1.0" and "Game state phase: lobby"
- nodemon watches for file changes and restarts automatically
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (2 tests in shared package)
- `pnpm lint` passes with no errors

**Files Created**:
- packages/server/nodemon.json

**Files Modified**:
- packages/server/package.json (added nodemon dependency, changed dev script)
- packages/shared/package.json (added type:module for ESM runtime support)

---

### 2026-01-25: Infrastructure - Client Hot-Reload Configuration

**Feature Completed**: "Client hot-reload configured with Vite"

**Work Done**:
- Verified Vite is already configured in client package with @vitejs/plugin-react
- Vite configuration includes React plugin which enables Fast Refresh (HMR) by default
- Added `dev:client` script to root package.json: `pnpm --filter @jarls/client dev`
- Also added `dev:server` script for consistency: `pnpm --filter @jarls/server dev`
- Tested Vite dev server starts correctly on http://localhost:5173/
- Verified HMR is working:
  - `/@react-refresh` is injected for React Fast Refresh
  - `/@vite/client` is loaded for Vite's HMR client
  - HMRContext class is properly initialized

**Verification**:
- `pnpm dev:client` starts Vite dev server successfully
- Server responds with HTML containing HMR scripts
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (2 tests in shared package)
- `pnpm lint` passes with no errors

**Files Modified**:
- package.json (added dev:client and dev:server scripts)

---

### 2026-01-25: Core Logic - HexDirection Type and DIRECTIONS Constant

**Feature Completed**: "HexDirection type and DIRECTIONS constant defined"

**Work Done**:
- Added HexDirection type (0-5) representing the 6 directions in a hexagonal grid
- Added DIRECTIONS constant array with all 6 direction vectors in cube coordinates
- Directions follow pointy-top hex orientation, counter-clockwise from East:
  - 0: East (q+1, r+0, s-1)
  - 1: Northeast (q+1, r-1, s+0)
  - 2: Northwest (q+0, r-1, s+1)
  - 3: West (q-1, r+0, s+1)
  - 4: Southwest (q-1, r+1, s+0)
  - 5: Southeast (q+0, r+1, s-1)
- Added comprehensive unit tests verifying:
  - Exactly 6 directions exist
  - All direction vectors satisfy cube coordinate constraint (q + r + s = 0)
  - All direction vectors are unit vectors (magnitude 2 in cube coords)
  - All directions are unique
  - Consistent hexagonal ordering (opposite directions are 3 apart)
  - HexDirection type works correctly as array index

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (8 tests total, 6 new tests for HexDirection/DIRECTIONS)

**Files Modified**:
- packages/shared/src/index.ts (added HexDirection type and DIRECTIONS constant)
- packages/shared/src/index.test.ts (added unit tests for HexDirection and DIRECTIONS)

---

### 2026-01-25: Core Logic - Coordinate Conversion Functions

**Feature Completed**: "axialToCube and cubeToAxial conversion functions work"

**Work Done**:
- Implemented `axialToCube(axial: AxialCoord): CubeCoord` function
  - Takes axial coordinates (q, r) and derives cube coordinates (q, r, s)
  - s component calculated from constraint q + r + s = 0
  - Handles -0 edge case by normalizing to 0
- Implemented `cubeToAxial(cube: CubeCoord): AxialCoord` function
  - Takes cube coordinates (q, r, s) and returns axial coordinates (q, r)
  - s component is discarded as it's redundant
- Added comprehensive unit tests:
  - Origin conversion tests
  - Positive and negative coordinate tests
  - Constraint verification (q + r + s = 0)
  - Round-trip conversion tests (axial -> cube -> axial)
  - Round-trip conversion tests (cube -> axial -> cube)

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (19 tests total, 11 new tests for conversion functions)

**Files Modified**:
- packages/shared/src/index.ts (added axialToCube and cubeToAxial functions)
- packages/shared/src/index.test.ts (added unit tests for conversion functions)

---

### 2026-01-25: Core Logic - Hex Distance Function

**Feature Completed**: "hexDistance function calculates correct distance"

**Work Done**:
- Implemented `hexDistance(a: CubeCoord, b: CubeCoord): number` function
  - Calculates shortest path length between two hexes using cube coordinates
  - Uses Manhattan distance formula: (|Δq| + |Δr| + |Δs|) / 2
- Implemented `hexDistanceAxial(a: AxialCoord, b: AxialCoord): number` function
  - Convenience wrapper that converts axial to cube coordinates internally
- Added comprehensive unit tests covering:
  - Distance from hex to itself is 0
  - Adjacent hexes have distance 1 (tested all 6 directions)
  - Hexes 2 steps away have distance 2
  - Hexes 3 steps away (board radius) have distance 3
  - Symmetry: distance(a, b) === distance(b, a)
  - Negative coordinates
  - Diagonal movement
  - Axial coordinate version matches cube version
  - Common game scenarios (edge to throne, opposite edges)

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (30 tests total, 11 new tests for hexDistance)

**Files Modified**:
- packages/shared/src/index.ts (added hexDistance and hexDistanceAxial functions)
- packages/shared/src/index.test.ts (added unit tests for hexDistance functions)

---

### 2026-01-25: Core Logic - Neighbor Functions

**Feature Completed**: "getNeighbor and getAllNeighbors functions work"

**Work Done**:
- Implemented `getNeighbor(hex: CubeCoord, direction: HexDirection): CubeCoord` function
  - Returns the adjacent hex in the specified direction
  - Uses DIRECTIONS array for direction vectors
- Implemented `getAllNeighbors(hex: CubeCoord): CubeCoord[]` function
  - Returns all 6 neighboring hexes around a given hex
  - Index corresponds to HexDirection (0=East, 1=NE, 2=NW, 3=West, 4=SW, 5=SE)
- Implemented `getNeighborAxial(hex: AxialCoord, direction: HexDirection): AxialCoord` function
  - Axial coordinate convenience wrapper
- Implemented `getAllNeighborsAxial(hex: AxialCoord): AxialCoord[]` function
  - Axial coordinate convenience wrapper
- Added comprehensive unit tests (25 new tests) covering:
  - All 6 directions individually verified
  - Cube coordinate constraint (q + r + s = 0) satisfied
  - All neighbors at distance 1
  - Negative coordinate handling
  - Inverse direction property (going East then West returns to origin)
  - Exactly 6 unique neighbors returned
  - Correct order matching DIRECTIONS array
  - Consistency between individual and batch calls
  - Consistency between cube and axial versions

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (55 tests total, 25 new tests for neighbor functions)

**Files Modified**:
- packages/shared/src/index.ts (added getNeighbor, getAllNeighbors, getNeighborAxial, getAllNeighborsAxial)
- packages/shared/src/index.test.ts (added unit tests for neighbor functions)

---

### 2026-01-25: Core Logic - getOppositeDirection Function

**Feature Completed**: "getOppositeDirection function returns correct opposite"

**Work Done**:
- Implemented `getOppositeDirection(direction: HexDirection): HexDirection` function
  - Returns the opposite direction (180 degrees) for any given hex direction
  - Uses formula `(direction + 3) % 6` since opposites are 3 apart in the array
  - Direction mappings: 0↔3 (East↔West), 1↔4 (NE↔SW), 2↔5 (NW↔SE)
- Added comprehensive unit tests (10 new tests) covering:
  - All 6 individual direction-to-opposite mappings verified
  - Self-inverse property (applying twice returns original)
  - Opposite direction vectors sum to zero (0, 0, 0)
  - Return value is valid HexDirection type (0-5)
  - Round-trip navigation test (move in direction, then opposite returns to origin)

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (65 tests total, 10 new tests for getOppositeDirection)

**Files Modified**:
- packages/shared/src/index.ts (added getOppositeDirection function)
- packages/shared/src/index.test.ts (added unit tests for getOppositeDirection)

---

### 2026-01-25: Core Logic - hexLine Function

**Feature Completed**: "hexLine function draws line between two hexes"

**Work Done**:
- Implemented `cubeRound(q, r, s): CubeCoord` helper function
  - Rounds fractional cube coordinates to nearest valid hex
  - Uses constraint q + r + s = 0 to ensure valid coordinates
  - Component with largest rounding error is recalculated
  - Normalizes -0 to 0 to avoid equality issues
- Implemented `hexLine(a: CubeCoord, b: CubeCoord): CubeCoord[]` function
  - Uses linear interpolation in cube coordinates with proper rounding
  - Returns array of all hexes along the line from a to b (inclusive)
  - Handles edge cases where line passes exactly between hexes via nudge offset
  - Returns distance + 1 hexes for any line
- Implemented `hexLineAxial(a, b): AxialCoord[]` convenience wrapper
- Added comprehensive unit tests (21 new tests) covering:
  - Single hex when start equals end
  - Two hexes for adjacent hexes
  - Start and end hexes included
  - Correct number of hexes (distance + 1)
  - Straight lines in all 6 directions (East, West, Northeast, etc.)
  - Cube coordinate constraint satisfied for all hexes
  - Consecutive hexes at distance 1
  - Diagonal lines
  - Lines with negative coordinates
  - Symmetry (line a→b equals reversed line b→a)
  - Edge cases where lines pass between hexes
  - Axial coordinate version consistency
  - Game scenario: Jarl to Throne path

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (86 tests total, 21 new tests for cubeRound/hexLine/hexLineAxial)

**Files Modified**:
- packages/shared/src/index.ts (added cubeRound, hexLine, hexLineAxial functions)
- packages/shared/src/index.test.ts (added unit tests for all new functions)

---

### 2026-01-25: Core Logic - isOnBoard and isOnEdge Functions

**Feature Completed**: "isOnBoard and isOnEdge functions validate positions"

**Work Done**:
- Implemented `isOnBoard(hex: CubeCoord, radius: number): boolean` function
  - Returns true if hex is within board bounds (distance from center <= radius)
  - Uses hexDistance to calculate distance from center (0,0,0)
- Implemented `isOnBoardAxial(hex: AxialCoord, radius: number): boolean` function
  - Axial coordinate convenience wrapper
- Implemented `isOnEdge(hex: CubeCoord, radius: number): boolean` function
  - Returns true if hex is exactly at the board edge (distance from center === radius)
- Implemented `isOnEdgeAxial(hex: AxialCoord, radius: number): boolean` function
  - Axial coordinate convenience wrapper
- Added comprehensive unit tests (25 new tests) covering:
  - Center hex (Throne) validation
  - Hexes within board radius
  - Hexes outside board radius
  - All 6 cardinal edge positions
  - Radius 0 (single hex board)
  - Different board sizes (radius 1, 3, 5)
  - Negative coordinate positions
  - Edge hex count verification (6r edge hexes for radius r)
  - Consistency between cube and axial versions
  - Game scenarios: Jarl starting positions, Throne position, pushed-off pieces
  - Boundary cases for hexes adjacent to edge

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (111 tests total, 25 new tests for isOnBoard/isOnEdge)

**Files Modified**:
- packages/shared/src/index.ts (added isOnBoard, isOnBoardAxial, isOnEdge, isOnEdgeAxial functions)
- packages/shared/src/index.test.ts (added unit tests for all new functions)

---

### 2026-01-25: Core Logic - hexToKey and keyToHex Functions

**Feature Completed**: "hexToKey and keyToHex enable Map storage"

**Work Done**:
- Implemented `hexToKey(hex: CubeCoord | AxialCoord): string` function
  - Converts hex coordinates to a unique string key for Map storage
  - Uses format "q,r" for minimal storage (axial coordinates)
  - Works with both cube and axial coordinate inputs
- Implemented `keyToHex(key: string): AxialCoord | null` function
  - Converts string key back to axial coordinates
  - Returns null for invalid keys (wrong format, non-numeric values)
- Implemented `keyToHexCube(key: string): CubeCoord | null` function
  - Convenience wrapper that returns cube coordinates
  - Calculates s component from constraint q + r + s = 0
- Added comprehensive unit tests (23 new tests) covering:
  - Origin conversion
  - Positive, negative, and mixed coordinates
  - Cube coordinate input (uses q, r only)
  - Unique keys for different hexes
  - Consistent keys for same hex
  - Invalid key handling (wrong format, non-numeric)
  - Round-trip conversions (axial and cube)
  - Map storage scenarios including game board piece tracking

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (134 tests total, 23 new tests for hexToKey/keyToHex)

**Files Modified**:
- packages/shared/src/index.ts (added hexToKey, keyToHex, keyToHexCube functions)
- packages/shared/src/index.test.ts (added unit tests for all new functions)

---

### 2026-01-25: Core Logic - Game State Types Fully Defined

**Feature Completed**: "Game state types fully defined"

**Work Done**:
- Added MoveCommand interface for player move inputs:
  - pieceId: string to identify the piece being moved
  - destination: AxialCoord for the target position
- Added CombatBreakdown interface for attack/defense calculation details:
  - baseStrength, momentum, support, total breakdown
- Added CombatResult interface for combat preview:
  - attackerId, defenderId, attack/defense breakdowns
  - outcome ('push' | 'blocked'), pushDirection
- Added ValidMove interface for move validation:
  - destination, moveType ('move' | 'attack'), hasMomentum
  - combatPreview for attack moves
- Added MoveResult interface for move execution results:
  - success, error (optional), newState, events array
- Added GameEvent union type with all event types:
  - MoveEvent: piece movement tracking
  - PushEvent: push chain tracking with depth for animations
  - EliminatedEvent: piece elimination (edge or starvation)
  - TurnEndedEvent: turn transitions
  - GameEndedEvent: game conclusion with winner/condition
  - StarvationTriggeredEvent: starvation mechanic activation
  - StarvationResolvedEvent: starvation resolution
  - PlayerJoinedEvent, PlayerLeftEvent: lobby events
- All types properly exported from @jarls/shared

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (134 tests)

**Files Modified**:
- packages/shared/src/index.ts (added MoveCommand, CombatBreakdown, CombatResult, ValidMove, MoveResult, GameEvent and all individual event types)

---

### 2026-01-25: Core Logic - getConfigForPlayerCount Function

**Feature Completed**: "getConfigForPlayerCount returns correct scaling"

**Work Done**:
- Implemented `getConfigForPlayerCount(playerCount, turnTimerMs?)` function
  - Returns GameConfig object with scaling values from the ruleset
  - Supports 2-6 players with appropriate board radius, shield count, and warrior count
- Added PLAYER_SCALING constant with scaling table from ruleset:
  - 2 players: radius 3, 5 shields, 5 warriors (37 hexes, ~32% density)
  - 3 players: radius 5, 4 shields, 5 warriors (91 hexes, ~20% density)
  - 4 players: radius 6, 4 shields, 4 warriors (127 hexes, ~16% density)
  - 5 players: radius 7, 3 shields, 4 warriors (169 hexes, ~15% density)
  - 6 players: radius 8, 3 shields, 4 warriors (217 hexes, ~14% density)
- Function validates player count and throws error for invalid values (< 2 or > 6)
- Optional turnTimerMs parameter defaults to null (no timer)
- Added comprehensive unit tests (22 new tests) covering:
  - All player counts (2-6) with correct scaling values
  - Total hex count verification using formula 3r² + 3r + 1
  - Turn timer configurations (null, 30s, 60s, 120s)
  - Invalid player count error handling
  - Return type verification
  - Density scaling verification (decreasing density as player count increases)

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (156 tests total, 22 new tests for getConfigForPlayerCount)

**Files Modified**:
- packages/shared/src/index.ts (added PLAYER_SCALING constant and getConfigForPlayerCount function)
- packages/shared/src/index.test.ts (added unit tests for getConfigForPlayerCount)

---

### 2026-01-25: Core Logic - generateAllBoardHexes Function Verified

**Feature Completed**: "generateAllBoardHexes creates correct hex count"

**Work Done**:
- Verified existing implementation of `getBoardHexCount(radius)` function
  - Calculates total hexes using formula: 3r² + 3r + 1
  - Returns correct counts for all board sizes (1, 7, 19, 37, 91, 127, 169, 217)
- Verified existing implementation of `generateAllBoardHexes(radius)` function
  - Generates array of all valid CubeCoord positions for given radius
  - Iterates through q/r coordinates and derives s from constraint q + r + s = 0
  - Returns hexes in consistent order (by q, then by r)
- Verified existing implementation of `generateAllBoardHexesAxial(radius)` function
  - Convenience wrapper returning AxialCoord array
- Existing tests (27 tests) verify:
  - Radius 3 generates exactly 37 hexes
  - Formula 3r² + 3r + 1 verified for all standard board sizes
  - All hexes satisfy cube coordinate constraint (q + r + s = 0)
  - All hexes within board radius (isOnBoard returns true)
  - All unique hexes generated
  - Complete coverage (includes center/Throne, all edge hexes, all distances)
  - Consistency between cube and axial versions

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (183 tests total, 27 tests for getBoardHexCount/generateAllBoardHexes)

**Files Verified** (already existed):
- packages/shared/src/index.ts (getBoardHexCount, generateAllBoardHexes, generateAllBoardHexesAxial at lines 519-579)
- packages/shared/src/index.test.ts (tests at lines 1483-1719)

---

### 2026-01-25: Core Logic - calculateStartingPositions Function

**Feature Completed**: "calculateStartingPositions places Jarls equidistantly"

**Work Done**:
- Implemented `hexToPixel(hex, size)` helper function
  - Converts axial hex coordinates to pixel coordinates for rendering
  - Uses pointy-top hex orientation
  - Returns center point of the hex as { x, y }
- Implemented `hexToAngle(hex)` helper function
  - Calculates angle (in radians) from board center to a hex
  - Angle 0 is East, increasing counter-clockwise
  - Used for angular positioning of starting positions
- Implemented `calculateStartingPositions(playerCount, radius)` function
  - Returns array of AxialCoord positions, one per player
  - All Jarls start on edge hexes (distance from center = radius)
  - Jarls are positioned at evenly-spaced angles around the board
  - For N players: angles at 0, 2π/N, 4π/N, ..., (N-1)*2π/N radians
  - For 2 players: directly opposite edges (East and West)
  - Validates player count (2-6) and throws error for invalid values
- Added comprehensive unit tests (34 new tests) covering:
  - 2-player positions: exactly 2, opposite edges, equidistant from center
  - 3-player positions: exactly 3, all on edge, equidistant, spread angularly
  - All player counts (2-6): unique positions, all on edge, all equidistant from Throne
  - Error handling: invalid player counts (0, 1, 7, negative)
  - Position validity: all on board, none on Throne

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (217 tests total, 34 new tests for hexToPixel/hexToAngle/calculateStartingPositions)

**Files Modified**:
- packages/shared/src/index.ts (added hexToPixel, hexToAngle, calculateStartingPositions functions)
- packages/shared/src/index.test.ts (added unit tests for all new functions)

---

### 2026-01-25: Core Logic - generateSymmetricalShields Function

**Feature Completed**: "generateSymmetricalShields places shields fairly"

**Work Done**:
- Implemented `rotateHex(hex, steps)` helper function:
  - Rotates a hex position around the board center by 60-degree steps
  - Used for generating rotationally symmetric shield positions
  - Preserves distance from center and cube coordinate constraint
- Implemented `generateSymmetricalShields(playerCount, radius, shieldCount)` function:
  - Places shields with N-fold rotational symmetry (where N = playerCount)
  - Groups hexes by their "canonical" form under rotation to find symmetric positions
  - Prioritizes complete symmetric groups for fair gameplay
  - Falls back to partial placement when full symmetry isn't achievable
  - Shields are equidistant from all starting positions due to rotational symmetry
- Position constraints enforced:
  - No shield on the Throne (center hex at 0,0)
  - No shield on edge hexes (where pieces start and can be pushed off)
  - All shields placed in interior hexes (0 < distance < radius)
- Added comprehensive unit tests (25 new tests) covering:
  - Basic functionality: correct shield count for all player configurations
  - Position constraints: not on Throne, not on edge, within board, interior only
  - Rotational symmetry: shields have symmetric partners under rotation
  - Equidistance: balanced distance sums to starting positions
  - Error handling: invalid player counts, insufficient space
  - Game scenarios: all standard configurations (2-6 players)

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (242 tests total, 25 new tests for rotateHex/generateSymmetricalShields)
- `pnpm lint` passes with no errors

**Files Modified**:
- packages/shared/src/index.ts (added rotateHex and generateSymmetricalShields functions)
- packages/shared/src/index.test.ts (added unit tests for new functions)

---

### 2026-01-25: Core Logic - validateShieldPlacement Function

**Feature Completed**: "validateShieldPlacement ensures path to Throne"

**Work Done**:
- Implemented `hasPathToThrone(startPosition, shieldPositions, radius)` function:
  - Checks if there's an unobstructed straight-line path from a starting position to the Throne
  - Uses `hexLineAxial` to get all hexes on the straight line from start to center
  - Returns true if no shields block any hex along the path (excluding start and end)
- Implemented `validateShieldPlacement(shieldPositions, startingPositions, radius)` function:
  - Validates that all players have at least one unobstructed path to the Throne
  - Returns object with `isValid` boolean and `blockedPlayers` array
  - `blockedPlayers` contains indices of players whose paths are all blocked
  - Uses Set for O(1) shield position lookups
- Added comprehensive unit tests (21 new tests) covering:
  - Basic path detection: clear paths, blocked paths
  - Various starting positions: West edge, Northeast area, Southwest area
  - Throne adjacency scenarios
  - Valid placement detection: no shields, non-blocking shields
  - Invalid placement detection: player 0 blocked, player 1 blocked, all blocked
  - Result structure validation for all player configurations (2-6)

**Note**: The current `generateSymmetricalShields` function may produce placements that block
some paths. This is expected behavior - the `validateShieldPlacement` function correctly
identifies these invalid placements, allowing the game setup process to regenerate shields
when needed.

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (263 tests total, 21 new tests for hasPathToThrone/validateShieldPlacement)
- `pnpm lint` passes with no errors

**Files Modified**:
- packages/shared/src/index.ts (added hasPathToThrone and validateShieldPlacement functions)
- packages/shared/src/index.test.ts (added unit tests for new functions)

---

### 2026-01-25: Core Logic - placeWarriors Function

**Feature Completed**: "placeWarriors positions Warriors in front of Jarl"

**Work Done**:
- Implemented `getDirectionTowardThrone(startPosition)` helper function:
  - Finds the hex direction that most closely points from a starting position toward the Throne
  - Used to determine which direction Warriors should be placed (in front of the Jarl)
  - Returns the HexDirection (0-5) that minimizes distance to the Throne when moving from the start position
- Implemented `placeWarriors(jarlPosition, warriorCount, shieldPositions, radius)` function:
  - Places Warriors between the Jarl and the Throne in a line formation
  - Uses `hexLineAxial` to get hexes on the direct path from Jarl to Throne
  - Warriors are placed on available hexes along the path, skipping shields and the Throne
  - If direct path is blocked by shields, falls back to adjacent hexes prioritizing the direction toward the Throne
  - Respects all placement constraints: no overlap with Jarl, shields, or Throne
- Added comprehensive unit tests (21 new tests) covering:
  - Basic placement: correct count, zero/negative counts, unique positions
  - Position constraints: not on Jarl, not on Throne, not on shields, within board bounds
  - Formation toward throne: warriors placed between Jarl and Throne, line formation when path is clear
  - Shield avoidance: places warriors around shields, finds alternate positions when path blocked
  - Game scenarios: standard 2-player configurations, diagonal positions, full game setup with shields

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (284 tests total, 21 new tests for getDirectionTowardThrone/placeWarriors)

**Files Modified**:
- packages/shared/src/index.ts (added getDirectionTowardThrone and placeWarriors functions)
- packages/shared/src/index.test.ts (added unit tests for new functions)

---

### 2026-01-25: Core Logic - createInitialState Function

**Feature Completed**: "createInitialState generates complete game state"

**Work Done**:
- Implemented `generateId()` helper function:
  - Generates unique IDs for game entities using timestamp + random string
  - Used for game ID, player IDs, and piece IDs
- Implemented `createInitialState(playerNames, turnTimerMs?)` function:
  - Creates a complete GameState object ready for gameplay
  - Accepts array of player names (2-6 players) and optional turn timer
  - Creates Player objects with unique IDs, names, and distinct colors
  - Calculates Jarl starting positions using `calculateStartingPositions`
  - Generates shield positions using `generateSymmetricalShields` with path validation
  - Places Jarls on edge hexes at starting positions
  - Places Warriors in front of each Jarl using `placeWarriors`
  - Sets game phase to 'setup'
  - Initializes all counters (turnNumber, roundNumber, roundsSinceElimination) to 0
  - Sets first player as currentPlayerId
- Enhanced `generateSymmetricalShields` to accept optional starting positions:
  - Avoids placing shields on direct paths from starting positions to Throne
  - Ensures valid shield placements that don't block all paths for any player
- Added PLAYER_COLORS constant for up to 6 distinct player colors
- Added comprehensive unit tests (36 new tests) covering:
  - Basic creation: all required fields, unique IDs, initial counters
  - Player initialization: correct count, names, unique IDs, distinct colors, not eliminated
  - Configuration: correct config for player counts, turn timer handling
  - Piece placement: correct counts, positions, player assignments, uniqueness
  - Error handling: invalid player counts
  - Game scenarios: all supported player counts, consistent structure, proper Warrior positioning

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (320 tests total, 36 new tests for generateId/createInitialState)

**Files Modified**:
- packages/shared/src/index.ts (added PLAYER_COLORS, generateId, createInitialState; enhanced generateSymmetricalShields)
- packages/shared/src/index.test.ts (added unit tests for generateId and createInitialState)

---

### 2026-01-25: Core Logic - getPieceAt and getPieceById Helper Functions

**Feature Completed**: "getPieceAt and getPieceById helpers work"

**Work Done**:
- Implemented `getPieceAt(state, position)` function:
  - Returns the piece at a specific position on the board
  - Returns undefined if no piece exists at the given position
  - Uses `hexToKey` for efficient position comparison
- Implemented `getPieceById(state, pieceId)` function:
  - Returns the piece with the specified unique ID
  - Returns undefined if no piece with the given ID exists
- Both functions handle edge cases gracefully:
  - Empty pieces array returns undefined
  - Off-board positions return undefined
  - Non-existent IDs return undefined
- Added comprehensive unit tests (19 new tests) covering:
  - Basic piece retrieval by position and ID
  - Finding Jarls, Warriors, and Shields correctly
  - Handling missing pieces (undefined return)
  - Empty state handling
  - Verifying correct piece object reference is returned
  - Testing across different player counts (2-6)

**Verification**:
- `pnpm typecheck` passes for all packages
- `pnpm test` passes (339 tests total, 19 new tests for getPieceAt/getPieceById)

**Files Modified**:
- packages/shared/src/index.ts (added getPieceAt and getPieceById functions)
- packages/shared/src/index.test.ts (added unit tests for getPieceAt and getPieceById)
